{
    "docs": [
        {
            "location": "/",
            "text": "ILLIXR\n\n\n\n\n\n\n\n\n\n\nIllinois Extended Reality testbed or ILLIXR (pronounced like elixir) is the first open-source full-system Extended Reality (XR) testbed. It contains standalone state-of-the-art components representative of a generic XR workflow, as well as a runtime framework that integrates these components into an XR system. ILLIXR's runtime integration framework is modular, extensible, and \nOpenXR\n-compatible.\n\n\nWe use the term \ncomponents\n and not \nkernels\n or \ncomputations\n because each component of ILLIXR is an entire application in itself, and consists of many kernels and computations. At the moment, ILLIXR contains the following state-of-the-art components, all of which can be found packaged together in the \nv1-latest release\n of ILLIXR.\n\n\n\n\nSimultaneous Localization and Mapping\n\n\nScene reconstruction\n\n\nEye tracking\n\n\nAmbisonic encoding\n\n\nAmbisonic manipulation and binauralization\n\n\nLens distortion correction\n\n\nChromatic aberration correction\n\n\nTime warp\n\n\nComputational holography for adaptive multi-focal displays\n\n\n\n\nWe plan on adding more components (e.g., graphics and multiple versions for individual components) and extending the runtime in the future. Our goal is not to create a commercial quality XR product for current hardware. Instead, the goal for ILLIXR is to advance computer architecture, systems, and hardware-software co-design research for XR by making available a full system and key state-of-the-art components of both modern and future XR applications.\n\n\nMany of the current components of ILLIXR were developed by domain experts and obtained from publicly available repositories. They were modified for one or more of the following reasons: fixing compilation, adding features, or removing extraneous code or dependencies. Each component not developed by us is available as a forked github repository for proper attribution to its authors.\n\n\nDetailed descriptions of each component and our runtime, including performance and energy profiles, can be found in our \npaper\n.\n\n\nPublications\n\n\nWe request that you cite our following paper (new version coming soon) when you use ILLIXR for a publication. We would also appreciate it if you send us a citation once your work has been published.\n\n\n@misc{HuzaifaDesai2020,\n    title={Exploring Extended Reality with ILLIXR: A new Playground for Architecture Research},\n    author={Muhammad Huzaifa and Rishi Desai and Xutao Jiang and Joseph Ravichandran and Finn Sinclair and Sarita V. Adve},\n    year={2020},\n    eprint={2004.04643},\n    primaryClass={cs.DC}\n}\n\n\n\n\nGetting Started and Documentation\n\n\nFor more information, see our \ngetting started page\n.\n\n\nAcknowledgements\n\n\nMuhammad Huzaifa led the development of ILLIXR in \nSarita Adve\u2019s research group\n at the University of Illinois at Urbana-Champaign. Other major contributors include Rishi Desai, Samuel Grayson, Xutao Jiang, Ying Jing, Jae Lee, Fang Lu, Joseph Ravichandran, Finn Sinclair, Henghzhi Yuan, Jeffrey Zhang.\n\n\nILLIXR came together after many consultations with researchers and practitioners in many domains: audio, graphics, optics, robotics, signal processing, and extended reality systems. We are deeply grateful for all of these discussions and specifically to the following: Wei Cu, Aleksandra Faust, Liang Gao, Matt Horsnell, Amit Jindal, Steve LaValle, Steve Lovegrove, Andrew Maimone, Vegard \u00d8ye, Martin Persson, Archontis Politis, Eric Shaffer, Paris Smaragdis, Sachin Talathi, and Chris Widdowson.\n\n\nOur OpenXR implementation is derived from \nMonado\n. We are particularly thankful to Jakob Bornecrantz and Ryan Pavlik.\n\n\nThe development of ILLIXR was supported by the Applications Driving Architectures (ADA) Research Center, a JUMP Center co-sponsored by SRC and DARPA, the Center for Future Architectures Research (C-FAR), one of the six centers of STARnet, a Semiconductor Research Corporation program sponsored by MARCO and DARPA, and by a Google Faculty Research Award. The development of ILLIXR was also aided by generous hardware and software donations from ARM and NVIDIA. Facebook Reality Labs provided the \nOpenEDS Semantic Segmentation Dataset\n.\n\n\nWesley Darvin came up with the name for ILLIXR.\n\n\nLicensing Structure\n\n\nILLIXR is available as open-source software under the \nUniversity of Illinois/NCSA Open Source License\n. As mentioned above, ILLIXR largely consists of components developed by domain experts and modified for the purposes of inclusion in ILLIXR. However, ILLIXR does contain software developed solely by us. \nThe NCSA license is limited to only this software\n. The external libraries and softwares included in ILLIXR each have their own licenses and must be used according to those licenses:\n\n\n\n\nOpen-VINS\n - \nGNU General Public License v3.0\n\n\nElasticFusion\n - \nElasticFusion license\n\n\nRITnet\n - \nMIT License\n\n\nlibspatialaudio\n - \nGNU Lesser General Public License v2.1\n\n\nHOTlab\n - \nGNU Lesser General Public License v3.0\n\n\nMonado\n - \nBoost Software License 1.0\n\n\n\n\nGet In Touch\n\n\nWhether you are a computer architect, a systems person, an XR application developer, or just anyone interested in XR, we would love to hear your feedback on ILLIXR! ILLIXR is a living testbed and we would like to both refine existing components and add new ones. We believe ILLIXR has the opportunity to drive future computer architecture and systems research for XR, and can benefit from contributions from other researchers and organizations. If you would like to be a part of this effort, please contact us at \nillixr at cs dot illinois dot edu\n or visit us on \nGitter\n or just send us a pull request!",
            "title": "Home"
        },
        {
            "location": "/#illixr",
            "text": "Illinois Extended Reality testbed or ILLIXR (pronounced like elixir) is the first open-source full-system Extended Reality (XR) testbed. It contains standalone state-of-the-art components representative of a generic XR workflow, as well as a runtime framework that integrates these components into an XR system. ILLIXR's runtime integration framework is modular, extensible, and  OpenXR -compatible.  We use the term  components  and not  kernels  or  computations  because each component of ILLIXR is an entire application in itself, and consists of many kernels and computations. At the moment, ILLIXR contains the following state-of-the-art components, all of which can be found packaged together in the  v1-latest release  of ILLIXR.   Simultaneous Localization and Mapping  Scene reconstruction  Eye tracking  Ambisonic encoding  Ambisonic manipulation and binauralization  Lens distortion correction  Chromatic aberration correction  Time warp  Computational holography for adaptive multi-focal displays   We plan on adding more components (e.g., graphics and multiple versions for individual components) and extending the runtime in the future. Our goal is not to create a commercial quality XR product for current hardware. Instead, the goal for ILLIXR is to advance computer architecture, systems, and hardware-software co-design research for XR by making available a full system and key state-of-the-art components of both modern and future XR applications.  Many of the current components of ILLIXR were developed by domain experts and obtained from publicly available repositories. They were modified for one or more of the following reasons: fixing compilation, adding features, or removing extraneous code or dependencies. Each component not developed by us is available as a forked github repository for proper attribution to its authors.  Detailed descriptions of each component and our runtime, including performance and energy profiles, can be found in our  paper .",
            "title": "ILLIXR"
        },
        {
            "location": "/#publications",
            "text": "We request that you cite our following paper (new version coming soon) when you use ILLIXR for a publication. We would also appreciate it if you send us a citation once your work has been published.  @misc{HuzaifaDesai2020,\n    title={Exploring Extended Reality with ILLIXR: A new Playground for Architecture Research},\n    author={Muhammad Huzaifa and Rishi Desai and Xutao Jiang and Joseph Ravichandran and Finn Sinclair and Sarita V. Adve},\n    year={2020},\n    eprint={2004.04643},\n    primaryClass={cs.DC}\n}",
            "title": "Publications"
        },
        {
            "location": "/#getting-started-and-documentation",
            "text": "For more information, see our  getting started page .",
            "title": "Getting Started and Documentation"
        },
        {
            "location": "/#acknowledgements",
            "text": "Muhammad Huzaifa led the development of ILLIXR in  Sarita Adve\u2019s research group  at the University of Illinois at Urbana-Champaign. Other major contributors include Rishi Desai, Samuel Grayson, Xutao Jiang, Ying Jing, Jae Lee, Fang Lu, Joseph Ravichandran, Finn Sinclair, Henghzhi Yuan, Jeffrey Zhang.  ILLIXR came together after many consultations with researchers and practitioners in many domains: audio, graphics, optics, robotics, signal processing, and extended reality systems. We are deeply grateful for all of these discussions and specifically to the following: Wei Cu, Aleksandra Faust, Liang Gao, Matt Horsnell, Amit Jindal, Steve LaValle, Steve Lovegrove, Andrew Maimone, Vegard \u00d8ye, Martin Persson, Archontis Politis, Eric Shaffer, Paris Smaragdis, Sachin Talathi, and Chris Widdowson.  Our OpenXR implementation is derived from  Monado . We are particularly thankful to Jakob Bornecrantz and Ryan Pavlik.  The development of ILLIXR was supported by the Applications Driving Architectures (ADA) Research Center, a JUMP Center co-sponsored by SRC and DARPA, the Center for Future Architectures Research (C-FAR), one of the six centers of STARnet, a Semiconductor Research Corporation program sponsored by MARCO and DARPA, and by a Google Faculty Research Award. The development of ILLIXR was also aided by generous hardware and software donations from ARM and NVIDIA. Facebook Reality Labs provided the  OpenEDS Semantic Segmentation Dataset .  Wesley Darvin came up with the name for ILLIXR.",
            "title": "Acknowledgements"
        },
        {
            "location": "/#licensing-structure",
            "text": "ILLIXR is available as open-source software under the  University of Illinois/NCSA Open Source License . As mentioned above, ILLIXR largely consists of components developed by domain experts and modified for the purposes of inclusion in ILLIXR. However, ILLIXR does contain software developed solely by us.  The NCSA license is limited to only this software . The external libraries and softwares included in ILLIXR each have their own licenses and must be used according to those licenses:   Open-VINS  -  GNU General Public License v3.0  ElasticFusion  -  ElasticFusion license  RITnet  -  MIT License  libspatialaudio  -  GNU Lesser General Public License v2.1  HOTlab  -  GNU Lesser General Public License v3.0  Monado  -  Boost Software License 1.0",
            "title": "Licensing Structure"
        },
        {
            "location": "/#get-in-touch",
            "text": "Whether you are a computer architect, a systems person, an XR application developer, or just anyone interested in XR, we would love to hear your feedback on ILLIXR! ILLIXR is a living testbed and we would like to both refine existing components and add new ones. We believe ILLIXR has the opportunity to drive future computer architecture and systems research for XR, and can benefit from contributions from other researchers and organizations. If you would like to be a part of this effort, please contact us at  illixr at cs dot illinois dot edu  or visit us on  Gitter  or just send us a pull request!",
            "title": "Get In Touch"
        },
        {
            "location": "/building_illixr/",
            "text": "Building ILLIXR\n\n\nBasic usage\n\n\nWe have a tool called \nrunner.sh\n that downloads, compiles, and runs ILLIXR. This is necessary,\nsince ILLIXR has plugins and data are in many different places. The tool consumes a config YAML file\nwhich specifies those places.\n\n\nTo run ILLIXR natively, use\n\n\n./runner.sh configs/native.yaml\n\n\n\n\nTo drop into \ngdb\n, add \ncommand: gdb -q --args %a\n in the \nloader\n block of \nconfigs/native.yaml\n, and use the same command.\n\n\nTo run ILLIXR with Monado,\n\n\n./runner.sh configs/monado.yaml\n\n\n\n\nThe OpenXR application to run is defined in \nloader.openxr_app\n.\n\n\nConfig file\n\n\n\n\nSee \nconfig/{native,ci,native-ground-truth,monado}.yaml\n.\n\n\n\n\nThe first block in the config file contains a list of \nplugin_groups\n, where each \nplugin_group\n is a list of plugins.\n\n\nplugin_groups:\n  - plugin_group:\n      - path: plugin1/\n      - path: plugin2/\n      - path: plugin3/\n      - path: plugin4/\n\n\n\n\nThis defines a list of plugins by their location, \npath\n. Allowed paths will be described below. The\n\nplugin_groups\n get flattened and those plugins are initialized \nin order\n at runtime. Several of\nthe default plugins are order-sensitive.\n\n\nThe next block in the config defines the offline IMU data, camera data, and ground-truth data.\n\n\ndata:\n  subpath: mav0\n  relative_to:\n    archive_path:\n      download_url: 'http://robotics.ethz.ch/~asl-datasets/ijrr_euroc_mav_dataset/vicon_room1/V1_02_medium/V1_02_medium.zip'\n\n\n\n\nNext, we define the location of OBJ files for \ngldemo\n.\n\n\ndemo_data: demo_data/\n\n\n\n\nCurrently we support the following loaders: \nnative\n (which runs ILLIXR in standalone mode), \ntests\n\n(which runs integreation tests headlessly for CI/CD purposes), and \nmonado\n (which runs an OpenXR\napplication in Monado using ILLIXR as a backend).\n\n\nloader:\n  name: native\n  command: gdb -q --args %a\n\n\n\n\nThe \nnative\n loader supports an optional \ncommand\n argument. In that argument \n%a\n is replaced with\nthe separated command-line arguments to run ILLIR, while \n%b\n is replaced with the stringified\ncommand-line arguments.\n\n\nFinally, we support two profiles: \nopt\n, which compiles with \n-O3\n and disables debug prints, and\n\ndbg\n, which compiles with debug flags and enables debug prints.\n\n\nprofile: opt\n\n\n\n\nYou can \n!include\n other YAML files (\ndocumentation\n). Consider separating the site-specific\nconfiguration options into its own file.\n\n\nSpecifying Paths\n\n\nA path refers to a location of a resource. There are 5 ways of specifying a path:\n\n\n\n\nSimple path\n: either absolute or relative path in the native filesystem.\n\n\nGit repo\n: A git repository.\n\n\n\n\n- git_repo: https://github.com/user/repo.git\n  version: master # branch name, SHA-256, or tag\n\n\n\n\n\n\nDownload URL\n: A resource downloaded from the internet.\n\n\n\n\n- download_url: https://example.com/file.txt\n\n\n\n\n\n\nZip archive\n: A path that points within the contents of a zip archive. Note that \narchive_path\n is itself a path (recursive).\n\n\n\n\n- archive_path: path/to/archive.zip\n- archive_path:\n    download_url: https://example.com/file.zip\n\n\n\n\n\n\nComplex path\n: A hard-coded path relative to another path (recursive). This is useful to specify a \nsubdirectory\n of a git repository or zip archive.\n\n\n\n\n- subpath: path/within/git_repo\n  relative_to:\n    git_repo: ...\n    version: ...\n\n\n\n\nRationale\n\n\n\n\n\n\nPreviously, we would have to specify which plugins to build and which to run separately, violating\n  \nDRY principle\n.\n\n\n\n\n\n\nPreviously, configuration had to be hard-coded into the component source code, or passed as\n  parsed/unparsed as strings in env-vars on a per-component basis. This gives us a consistent way to\n  deal with all configurations.\n\n\n\n\n\n\nCurrently, plugins are specificed by a path to the directory containing their source code and\n  build system.\n\n\n\n\n\n\nPhilosophy\n\n\n\n\n\n\nEach plugin should not have to know or care how the others are compiled. In the future, they may\n  even be distributed separately, just as SOs. Therefore, each plugin needs its own build system.\n\n\n\n\n\n\nDespite this per-plugin flexibility, building the 'default' set of ILLIXR plugins should be\n  extremely easy.\n\n\n\n\n\n\nIt should be easy to build in parallel.\n\n\n\n\n\n\nAlways rebuild every time, so the binary is always \"fresh\". This is a great convenience when\n  experimenting. However, this implies that rebuilding must be fast when not much has changed.\n\n\n\n\n\n\nMake is the de facto standard for building C/C++ programs. GNU Make, and the\n  makefile language begets no shortage of problems [\n1\n,\n2\n,\n3\n,\n4\n,\n5\n], but we choose\n  Make for its tradeoff of between simplicity and functionality. What it lacks in functionality\n  (compared to CMake, Ninja, scons, Bazel, Meson) it makes up for in simplicity. It's still the\n  build system in which it is the easiest to invoke arbitrary commands in shell and the easiest to\n  have a \ncommon.mk\n included in each plugin. This decision to use Make should be revisited, when\n  this project outgrows its ability, but for now, Make remains, in our judgement, \nthe best tool for\n  the job\n.",
            "title": "Building illixr"
        },
        {
            "location": "/building_illixr/#building-illixr",
            "text": "",
            "title": "Building ILLIXR"
        },
        {
            "location": "/building_illixr/#basic-usage",
            "text": "We have a tool called  runner.sh  that downloads, compiles, and runs ILLIXR. This is necessary,\nsince ILLIXR has plugins and data are in many different places. The tool consumes a config YAML file\nwhich specifies those places.  To run ILLIXR natively, use  ./runner.sh configs/native.yaml  To drop into  gdb , add  command: gdb -q --args %a  in the  loader  block of  configs/native.yaml , and use the same command.  To run ILLIXR with Monado,  ./runner.sh configs/monado.yaml  The OpenXR application to run is defined in  loader.openxr_app .",
            "title": "Basic usage"
        },
        {
            "location": "/building_illixr/#config-file",
            "text": "See  config/{native,ci,native-ground-truth,monado}.yaml .   The first block in the config file contains a list of  plugin_groups , where each  plugin_group  is a list of plugins.  plugin_groups:\n  - plugin_group:\n      - path: plugin1/\n      - path: plugin2/\n      - path: plugin3/\n      - path: plugin4/  This defines a list of plugins by their location,  path . Allowed paths will be described below. The plugin_groups  get flattened and those plugins are initialized  in order  at runtime. Several of\nthe default plugins are order-sensitive.  The next block in the config defines the offline IMU data, camera data, and ground-truth data.  data:\n  subpath: mav0\n  relative_to:\n    archive_path:\n      download_url: 'http://robotics.ethz.ch/~asl-datasets/ijrr_euroc_mav_dataset/vicon_room1/V1_02_medium/V1_02_medium.zip'  Next, we define the location of OBJ files for  gldemo .  demo_data: demo_data/  Currently we support the following loaders:  native  (which runs ILLIXR in standalone mode),  tests \n(which runs integreation tests headlessly for CI/CD purposes), and  monado  (which runs an OpenXR\napplication in Monado using ILLIXR as a backend).  loader:\n  name: native\n  command: gdb -q --args %a  The  native  loader supports an optional  command  argument. In that argument  %a  is replaced with\nthe separated command-line arguments to run ILLIR, while  %b  is replaced with the stringified\ncommand-line arguments.  Finally, we support two profiles:  opt , which compiles with  -O3  and disables debug prints, and dbg , which compiles with debug flags and enables debug prints.  profile: opt  You can  !include  other YAML files ( documentation ). Consider separating the site-specific\nconfiguration options into its own file.",
            "title": "Config file"
        },
        {
            "location": "/building_illixr/#specifying-paths",
            "text": "A path refers to a location of a resource. There are 5 ways of specifying a path:   Simple path : either absolute or relative path in the native filesystem.  Git repo : A git repository.   - git_repo: https://github.com/user/repo.git\n  version: master # branch name, SHA-256, or tag   Download URL : A resource downloaded from the internet.   - download_url: https://example.com/file.txt   Zip archive : A path that points within the contents of a zip archive. Note that  archive_path  is itself a path (recursive).   - archive_path: path/to/archive.zip\n- archive_path:\n    download_url: https://example.com/file.zip   Complex path : A hard-coded path relative to another path (recursive). This is useful to specify a  subdirectory  of a git repository or zip archive.   - subpath: path/within/git_repo\n  relative_to:\n    git_repo: ...\n    version: ...",
            "title": "Specifying Paths"
        },
        {
            "location": "/building_illixr/#rationale",
            "text": "Previously, we would have to specify which plugins to build and which to run separately, violating\n   DRY principle .    Previously, configuration had to be hard-coded into the component source code, or passed as\n  parsed/unparsed as strings in env-vars on a per-component basis. This gives us a consistent way to\n  deal with all configurations.    Currently, plugins are specificed by a path to the directory containing their source code and\n  build system.",
            "title": "Rationale"
        },
        {
            "location": "/building_illixr/#philosophy",
            "text": "Each plugin should not have to know or care how the others are compiled. In the future, they may\n  even be distributed separately, just as SOs. Therefore, each plugin needs its own build system.    Despite this per-plugin flexibility, building the 'default' set of ILLIXR plugins should be\n  extremely easy.    It should be easy to build in parallel.    Always rebuild every time, so the binary is always \"fresh\". This is a great convenience when\n  experimenting. However, this implies that rebuilding must be fast when not much has changed.    Make is the de facto standard for building C/C++ programs. GNU Make, and the\n  makefile language begets no shortage of problems [ 1 , 2 , 3 , 4 , 5 ], but we choose\n  Make for its tradeoff of between simplicity and functionality. What it lacks in functionality\n  (compared to CMake, Ninja, scons, Bazel, Meson) it makes up for in simplicity. It's still the\n  build system in which it is the easiest to invoke arbitrary commands in shell and the easiest to\n  have a  common.mk  included in each plugin. This decision to use Make should be revisited, when\n  this project outgrows its ability, but for now, Make remains, in our judgement,  the best tool for\n  the job .",
            "title": "Philosophy"
        },
        {
            "location": "/debugging_illixr/",
            "text": "ILLIXR Debugging Tips\n\n\nDebugging Locally\n\n\nThe config described in \nBuilding ILLIXR\n supports running the runtime with arbitrary commands like \ngdb\n. When debugging locally we recommend using either \ngdb\n or \nvalgrind\n in this way.\n\n\nDebugging PRs\n\n\nRunning the CI/CD Docker Container Locally\n\n\nFollow these steps when a CI/CD build fails on a PR:\n\n\n\n\nClick details on the failing build\n\n\nIn the build view go to the Push Docker Image tab and copy the \ndocker push ghcr.io/illixr/illixr-tests:<branch-name>\n command\n\n\nThen in your terminal run \ndocker pull ghcr.io/illixr/illixr-tests:<branch-name>\n\n\nFinally run \ndocker run -it --entrypoint /bin/bash ghcr.io/illixr/illixr-tests:<branch-name>\n\n\n\n\nThis now gives you a bash shell in a docker container with all of the code that ran on CI/CD.",
            "title": "Debugging illixr"
        },
        {
            "location": "/debugging_illixr/#illixr-debugging-tips",
            "text": "",
            "title": "ILLIXR Debugging Tips"
        },
        {
            "location": "/debugging_illixr/#debugging-locally",
            "text": "The config described in  Building ILLIXR  supports running the runtime with arbitrary commands like  gdb . When debugging locally we recommend using either  gdb  or  valgrind  in this way.",
            "title": "Debugging Locally"
        },
        {
            "location": "/debugging_illixr/#debugging-prs",
            "text": "",
            "title": "Debugging PRs"
        },
        {
            "location": "/debugging_illixr/#running-the-cicd-docker-container-locally",
            "text": "Follow these steps when a CI/CD build fails on a PR:   Click details on the failing build  In the build view go to the Push Docker Image tab and copy the  docker push ghcr.io/illixr/illixr-tests:<branch-name>  command  Then in your terminal run  docker pull ghcr.io/illixr/illixr-tests:<branch-name>  Finally run  docker run -it --entrypoint /bin/bash ghcr.io/illixr/illixr-tests:<branch-name>   This now gives you a bash shell in a docker container with all of the code that ran on CI/CD.",
            "title": "Running the CI/CD Docker Container Locally"
        },
        {
            "location": "/default_plugins/",
            "text": "Default Plugins\n\n\n\n\n\n\noffline_imu_cam\n: Reads IMU data and images from files on disk, emulating a real sensor on the\n  headset (feeds input measurements with timing similar to an actual IMU).\n\n\n\n\n\n\nground_truth_slam\n: Reads the ground-truth from the same dataset to compare our output against\n  (uses timing from \noffline_imu_cam\n).\n\n\n\n\n\n\nopen_vins\n: Runs OpenVINS (\nupstream\n) on the input, and outputs a the headset's pose. In practice, this\n  publishes a fairly slow pose, so pose prediction is required to infer a fast pose. We do not yet\n  have pose prediction, so we say \nopen_vins\n also publishes a fast pose.\n\n\n\n\n\n\ngldemo\n: Renders a static scene (into left and right eyebuffers) given the pose from \nopen_vins\n.\n\n\n\n\n\n\ntimewarp_gl\n: \nAsynchronous reprojection\n of the eyebuffers.\n\n\n\n\n\n\ndebugview\n: Renders a frame for debug information.\n\n\n\n\n\n\naudio\n: TODO: this. By default this is disabled, since it requires an NVIDIA GPU.\n\n\n\n\n\n\nhologram\n: TODO: this. By default this is disabled, since it requires an NVIDIA GPU.\n\n\n\n\n\n\nBelow this point, we will use Switchboard terminology. Read the \nAPI documentation on \nswitchboard\n for definitions.\n\n\n\n\n\n\n\n\nIn the above figure, rectangles are plugins, cylinders are topics (the graph is bipartitioned\n  between these two gorups).\n\n\n\n\n\n\nSolid arrows from plugins to topics represent publishing.\n\n\n\n\n\n\nSolid arrows from topics to plugins represent synchronous reading. They take some action for\n  \nevery\n event which gets published on the topic.\n\n\n\n\n\n\nSolid arrows from topics to plugins represent asynchronous reading. They need to know just the\n  \nlatest\n event on their topic.\n\n\n\n\n\n\nImagine the topic as a trough filing with events from its publisher, being drained by its\n  synchronous readers (AKA subscribers), while asynchronous readres just skim from the top.\n\n\n\n\n\n\nSee \nWriting Your Plugin\n to extend ILLIXR.",
            "title": "Default plugins"
        },
        {
            "location": "/default_plugins/#default-plugins",
            "text": "offline_imu_cam : Reads IMU data and images from files on disk, emulating a real sensor on the\n  headset (feeds input measurements with timing similar to an actual IMU).    ground_truth_slam : Reads the ground-truth from the same dataset to compare our output against\n  (uses timing from  offline_imu_cam ).    open_vins : Runs OpenVINS ( upstream ) on the input, and outputs a the headset's pose. In practice, this\n  publishes a fairly slow pose, so pose prediction is required to infer a fast pose. We do not yet\n  have pose prediction, so we say  open_vins  also publishes a fast pose.    gldemo : Renders a static scene (into left and right eyebuffers) given the pose from  open_vins .    timewarp_gl :  Asynchronous reprojection  of the eyebuffers.    debugview : Renders a frame for debug information.    audio : TODO: this. By default this is disabled, since it requires an NVIDIA GPU.    hologram : TODO: this. By default this is disabled, since it requires an NVIDIA GPU.    Below this point, we will use Switchboard terminology. Read the  API documentation on  switchboard  for definitions.     In the above figure, rectangles are plugins, cylinders are topics (the graph is bipartitioned\n  between these two gorups).    Solid arrows from plugins to topics represent publishing.    Solid arrows from topics to plugins represent synchronous reading. They take some action for\n   every  event which gets published on the topic.    Solid arrows from topics to plugins represent asynchronous reading. They need to know just the\n   latest  event on their topic.    Imagine the topic as a trough filing with events from its publisher, being drained by its\n  synchronous readers (AKA subscribers), while asynchronous readres just skim from the top.    See  Writing Your Plugin  to extend ILLIXR.",
            "title": "Default Plugins"
        },
        {
            "location": "/getting_started/",
            "text": "Getting Started\n\n\nILLIXR Runtime\n\n\nThese instructions have been tested with Ubuntu 18.04 and 20.04.\n\n\n\n\n\n\nClone the repository:\n\n\ngit clone --recursive --branch v2-latest https://github.com/ILLIXR/ILLIXR\n\n\n\n\n\n\n\nUpdate the submodules. Submodules are git repositories inside a git repository that need to be\n   pulled down separately:\n\n\ngit submodule update --init --recursive\n\n\n\n\n\n\n\nInstall dependencies. This script installs some Ubuntu/Debian packages and builds several dependencies\n   from source:\n\n\n./install_deps.sh\n\n\n\n\n\n\n\nInspect \nconfigs/native.yaml\n. The schema definition is in \nrunner/config_schema.yaml\n. For more\n   details on the runner and the config files, see \nBuilding ILLIXR\n.\n\n\n\n\n\n\nBuild and run ILLIXR standalone:\n\n\n./runner.sh configs/native.yaml\n\n\n\n\n\n\n\nIf so desired, you can run ILLIXR headlessly using \nxvfb\n:\n\n\n./runner.sh configs/headless.yaml\n\n\n\n\n\n\n\nILLIXR Runtime with Monado (supports OpenXR)\n\n\nILLIXR leverages \nMonado\n, an open-source implementation of \nOpenXR\n, to support a wide range\nof applications. Because of a low-level driver issue, Monado only supports Ubuntu 18.04+.\n\n\n\n\nCompile and run:\n./runner.sh configs/monado.yaml\n\n\n\n\n\n\n\nILLIXR Standalone\n\n\nILLIXR can also benchmark each component in isolation.\n\n\n\n\n\n\nClone the repository.\n\n\ngit clone --recursive --branch v1-latest https://github.com/ILLIXR/ILLIXR\n\n\n\n\n\n\n\nUpdate the submodules. Submodules are git repositories inside a git repository that need to be\n   pulled down separately.\n\n\ngit submodule update --init --recursive\n\n\n\n\n\n\n\nEach component is a directory in \nbenchmark\n. See those components for their documentation.\n\n\n\n\n\n\nVirtual Machine\n\n\nILLIXR can be run inside a Qemu-KVM image. Check out the instructions \nhere\n.\n\n\nNext steps\n\n\nThe source code is divided into the following directories:\n- \nruntime\n: create a runnable binary that loads every plugin.\n    * This contains Spindle, which is responsible for loading plugins.\n\n\n\n\n\n\ncommon\n: resources one might use in each plugin. Most plugins symlink this directory into theirs.\n\n\n\n\nContains the interface for Switchboard, which maintains event-streams (implementation is in \nruntime\n).\n\n\nContains the interface for Phonebook, which is a service-directory (implementation is in \nruntime\n).\n\n\n\n\n\n\n\n\na directory for each plugin. Almost all of the XR functionality is implemented in plugins. See\n  \nDefault Components\n for more details.\n\n\n\n\n\n\nTry browsing the source of plugins. If you edit any of the source files, the runner will\ndetect and rebuild the respective binary. If you want to add your own, see \nWriting Your Plugin\n.",
            "title": "Getting started"
        },
        {
            "location": "/getting_started/#getting-started",
            "text": "",
            "title": "Getting Started"
        },
        {
            "location": "/getting_started/#illixr-runtime",
            "text": "These instructions have been tested with Ubuntu 18.04 and 20.04.    Clone the repository:  git clone --recursive --branch v2-latest https://github.com/ILLIXR/ILLIXR    Update the submodules. Submodules are git repositories inside a git repository that need to be\n   pulled down separately:  git submodule update --init --recursive    Install dependencies. This script installs some Ubuntu/Debian packages and builds several dependencies\n   from source:  ./install_deps.sh    Inspect  configs/native.yaml . The schema definition is in  runner/config_schema.yaml . For more\n   details on the runner and the config files, see  Building ILLIXR .    Build and run ILLIXR standalone:  ./runner.sh configs/native.yaml    If so desired, you can run ILLIXR headlessly using  xvfb :  ./runner.sh configs/headless.yaml",
            "title": "ILLIXR Runtime"
        },
        {
            "location": "/getting_started/#illixr-runtime-with-monado-supports-openxr",
            "text": "ILLIXR leverages  Monado , an open-source implementation of  OpenXR , to support a wide range\nof applications. Because of a low-level driver issue, Monado only supports Ubuntu 18.04+.   Compile and run: ./runner.sh configs/monado.yaml",
            "title": "ILLIXR Runtime with Monado (supports OpenXR)"
        },
        {
            "location": "/getting_started/#illixr-standalone",
            "text": "ILLIXR can also benchmark each component in isolation.    Clone the repository.  git clone --recursive --branch v1-latest https://github.com/ILLIXR/ILLIXR    Update the submodules. Submodules are git repositories inside a git repository that need to be\n   pulled down separately.  git submodule update --init --recursive    Each component is a directory in  benchmark . See those components for their documentation.",
            "title": "ILLIXR Standalone"
        },
        {
            "location": "/getting_started/#virtual-machine",
            "text": "ILLIXR can be run inside a Qemu-KVM image. Check out the instructions  here .",
            "title": "Virtual Machine"
        },
        {
            "location": "/getting_started/#next-steps",
            "text": "The source code is divided into the following directories:\n-  runtime : create a runnable binary that loads every plugin.\n    * This contains Spindle, which is responsible for loading plugins.    common : resources one might use in each plugin. Most plugins symlink this directory into theirs.   Contains the interface for Switchboard, which maintains event-streams (implementation is in  runtime ).  Contains the interface for Phonebook, which is a service-directory (implementation is in  runtime ).     a directory for each plugin. Almost all of the XR functionality is implemented in plugins. See\n   Default Components  for more details.    Try browsing the source of plugins. If you edit any of the source files, the runner will\ndetect and rebuild the respective binary. If you want to add your own, see  Writing Your Plugin .",
            "title": "Next steps"
        },
        {
            "location": "/modifying_a_plugin/",
            "text": "Modifying a plugin\n\n\nTutorial\n\n\nThis is how you can modify an existing ILLIXR plugin\n\n\n\n\n\n\nClone the repository for the component you want to modify. e.g: \ngit clone https://github.com/ILLIXR/audio_pipeline.git\n\n\n\n\n\n\nModify the config file like this:\n\n\nOriginal Config\n\n\nplugin_group:\n  - path: timewarp_gl/\n  - name: audio\n  path:\n    git_repo: https://github.com/ILLIXR/audio_pipeline.git\n    version: 3433bb452b2ec661c9d3ef65d9cf3a2805e94cdc\n\n\n\nNew Config\n\n\nplugin_group:\n  - path: timewarp_gl/\n  - name: /PATH/TO/LOCAL/AUDIO-PLUGIN\n\n\n\n\n\n\n\nSee the instructions on \nBuilding ILLIXR\n to learn how to run ILLIXR.\n\n\n\n\n\n\nTo push the modification to upstream ILLIXR, push up the changes to the plugin's repository and modify the original config with the commit version updated. Then create a PR on the main ILLIXR repository.",
            "title": "Modifying a plugin"
        },
        {
            "location": "/modifying_a_plugin/#modifying-a-plugin",
            "text": "",
            "title": "Modifying a plugin"
        },
        {
            "location": "/modifying_a_plugin/#tutorial",
            "text": "This is how you can modify an existing ILLIXR plugin    Clone the repository for the component you want to modify. e.g:  git clone https://github.com/ILLIXR/audio_pipeline.git    Modify the config file like this:  Original Config  plugin_group:\n  - path: timewarp_gl/\n  - name: audio\n  path:\n    git_repo: https://github.com/ILLIXR/audio_pipeline.git\n    version: 3433bb452b2ec661c9d3ef65d9cf3a2805e94cdc  New Config  plugin_group:\n  - path: timewarp_gl/\n  - name: /PATH/TO/LOCAL/AUDIO-PLUGIN    See the instructions on  Building ILLIXR  to learn how to run ILLIXR.    To push the modification to upstream ILLIXR, push up the changes to the plugin's repository and modify the original config with the commit version updated. Then create a PR on the main ILLIXR repository.",
            "title": "Tutorial"
        },
        {
            "location": "/monado_illixr_runtime_overview/",
            "text": "Monado Integration Overview\n\n\nILLIXR's plugins provide XR services, and the runtime ties them together. However, we don't want to\nforce developers to write \ntheir wohle application\n specifically for ILLIXR. As such, we want to\nimplement a common interface XR runtimes, such as \nOpenXR\n, so one application can work on\nseveral runtimes (including ours). In order to support OpenXR, we modified \nMonado\n, an existing,\nopen-source implementation.\n\n\n\n\n\n\nWhen running ILLIXR without Monado, the Illixr runtime is the entry-point. Phonebook and\n  switchboard are initialized and plugins are loaded, among which is the gldemo app.\n\n\n\n\n\n\nWhen running from Monado, however, as mandated by OpenXR specifications, the application is the\n  entry point. As a result, the Illixr runtime system is loaded at a later point as a shared\n  library. This article documents the changes to the Illixr runtime when an OpenXR application is\n  used.\n\n\n\n\n\n\n1. App launches and brings up Monado\n\n\nAs specified by OpenXR, the OpenXR application initializes the OpenXR runtime by reading a\nconfiguration JSON file pointed to by an environment variable and loads the OpenXR runtime, which is\nMonado in this case, as a shared library into its address space. Consult the OpenXR specifications\nand the OpenXR-SDK from Khronous Group for more details.\n\n\n2.  Monado probes HMD devices and Illixr Initializes\n\n\nDuring initialization, Monado asks all drivers to probe for and initialize HMDs and controllers,\ninternally known as \nxdev\ns.  We have an Illixr driver, which will always respond to Monado with one\ndiscovered HMD that will be used to capture OpenXR queries and events from Monado's state\ntracker. The Illixr driver obtains the path to the Illixr runtime so file and a list of plugins from\nenvironment variables.\n\n\nAfter probing is finished, the application will start to create an OpenXR session. At some point in\nthis process, the application will send its rendering context to the runtime, which we capture and\nsend to the Illixr driver. At this moment, all necessary data is ready and Illixr will be launched.\n\n\n3. Illixr Runtime Launch\n\n\nWhen used with Monado, the Illixr runtime is compiled into a shared library instead of an\nexecutable. The library exports its two major functionalities: initializing switchboard and\nphonebook, and load plugins.\n\n\nThe drivers starts to load the runtime by loading the shared library into the current (the app's)\naddress space and calls the switchboard and phonebook initialization. Then, it calls the plugin\nloading for each Illixr plugin (except gldemo, which is replaced by the OpenXR app). Finally, it\ncalls a special plugin loading which takes a function address instead of a file path to load a\ntranslation plugin into Illixr as the application. The translation plugin will be in the next\nsection. Each plugin should either not block or start its own thread, so the driver will be able to\nreacquire control and return to Monado and the app shortly.\n\n\n4. The translation plugin\n\n\nWhen the app and all Illixr plugins are up and running, the translation plugin handles the\nconnection between Monado and Illixr. It might be confusing to see that this plugin is part of the\nIllixr driver which is part of Monado while at the same time also part of Illixr as a plugin. But\nMonado and Illixr are running in different threads in the same address space. The translation plugin\nis the intersection of these two parallel systems serving as a bridge between the two.\n\n\nThe translation plugin handles two types of events at the moment: pose requests and frame\nsubmissions. From the view of Monado, it is the destination of all requests: from the application,\nto Monado's state trackers, to the xdev interface who is responsible for servicing the request. From\nthe view of Illixr, it behaves the same as the gldemo app: reading pose and submitting frames.\n\n\nFor implementation details regarding the representation of poses and frames in Monado and in Illixr,\nplease see Monado Integration Dataflow.",
            "title": "Monado illixr runtime overview"
        },
        {
            "location": "/monado_illixr_runtime_overview/#monado-integration-overview",
            "text": "ILLIXR's plugins provide XR services, and the runtime ties them together. However, we don't want to\nforce developers to write  their wohle application  specifically for ILLIXR. As such, we want to\nimplement a common interface XR runtimes, such as  OpenXR , so one application can work on\nseveral runtimes (including ours). In order to support OpenXR, we modified  Monado , an existing,\nopen-source implementation.    When running ILLIXR without Monado, the Illixr runtime is the entry-point. Phonebook and\n  switchboard are initialized and plugins are loaded, among which is the gldemo app.    When running from Monado, however, as mandated by OpenXR specifications, the application is the\n  entry point. As a result, the Illixr runtime system is loaded at a later point as a shared\n  library. This article documents the changes to the Illixr runtime when an OpenXR application is\n  used.",
            "title": "Monado Integration Overview"
        },
        {
            "location": "/monado_illixr_runtime_overview/#1-app-launches-and-brings-up-monado",
            "text": "As specified by OpenXR, the OpenXR application initializes the OpenXR runtime by reading a\nconfiguration JSON file pointed to by an environment variable and loads the OpenXR runtime, which is\nMonado in this case, as a shared library into its address space. Consult the OpenXR specifications\nand the OpenXR-SDK from Khronous Group for more details.",
            "title": "1. App launches and brings up Monado"
        },
        {
            "location": "/monado_illixr_runtime_overview/#2-monado-probes-hmd-devices-and-illixr-initializes",
            "text": "During initialization, Monado asks all drivers to probe for and initialize HMDs and controllers,\ninternally known as  xdev s.  We have an Illixr driver, which will always respond to Monado with one\ndiscovered HMD that will be used to capture OpenXR queries and events from Monado's state\ntracker. The Illixr driver obtains the path to the Illixr runtime so file and a list of plugins from\nenvironment variables.  After probing is finished, the application will start to create an OpenXR session. At some point in\nthis process, the application will send its rendering context to the runtime, which we capture and\nsend to the Illixr driver. At this moment, all necessary data is ready and Illixr will be launched.",
            "title": "2.  Monado probes HMD devices and Illixr Initializes"
        },
        {
            "location": "/monado_illixr_runtime_overview/#3-illixr-runtime-launch",
            "text": "When used with Monado, the Illixr runtime is compiled into a shared library instead of an\nexecutable. The library exports its two major functionalities: initializing switchboard and\nphonebook, and load plugins.  The drivers starts to load the runtime by loading the shared library into the current (the app's)\naddress space and calls the switchboard and phonebook initialization. Then, it calls the plugin\nloading for each Illixr plugin (except gldemo, which is replaced by the OpenXR app). Finally, it\ncalls a special plugin loading which takes a function address instead of a file path to load a\ntranslation plugin into Illixr as the application. The translation plugin will be in the next\nsection. Each plugin should either not block or start its own thread, so the driver will be able to\nreacquire control and return to Monado and the app shortly.",
            "title": "3. Illixr Runtime Launch"
        },
        {
            "location": "/monado_illixr_runtime_overview/#4-the-translation-plugin",
            "text": "When the app and all Illixr plugins are up and running, the translation plugin handles the\nconnection between Monado and Illixr. It might be confusing to see that this plugin is part of the\nIllixr driver which is part of Monado while at the same time also part of Illixr as a plugin. But\nMonado and Illixr are running in different threads in the same address space. The translation plugin\nis the intersection of these two parallel systems serving as a bridge between the two.  The translation plugin handles two types of events at the moment: pose requests and frame\nsubmissions. From the view of Monado, it is the destination of all requests: from the application,\nto Monado's state trackers, to the xdev interface who is responsible for servicing the request. From\nthe view of Illixr, it behaves the same as the gldemo app: reading pose and submitting frames.  For implementation details regarding the representation of poses and frames in Monado and in Illixr,\nplease see Monado Integration Dataflow.",
            "title": "4. The translation plugin"
        },
        {
            "location": "/monado_integration_dataflow/",
            "text": "Monado Integration Dataflow\n\n\nThe integration for monado in terms of dataflow can be divided into two parts, getting pose from\nillixr, and sending user rendered frame to illixr.\n\n\nIn monado, illixr looks like an HMD for monado, while in illixr, monado looks like a user\napplication as \ngldemo\n. After illixr is initialized from monado, and monado is registered as a\nplugin for illixr, most recent pose information is easy to get from switchboard.\n\n\nThe compositor side of monado integration with illixr is done in more subtle way. Original monado\ncompositor mostly does distortion correction and aberration correction in a vulkan back-end\ncompositor. It also has two client compositor, one for opengl app, the other for vulkan app, which\npass frame data to the back-end compositor. Illixr integration intercepts the frame at gl client\ncompositor and sends it to switchboard of illixr, which is then used by \ntimewarp_gl\n component.\n\n\nIn order to get a opengl frame and use it without copying pixels, illixr needs to get the user\napplication gl context. It is done at OpenXR session creation time, where illixr is\ninitialized. Note that logically illixr is initialized during OpenXR instance creation, or running\nat the background all the time. But, since illixr only supports single session at this time, and\nrequires a user application gl context upon initialization, illixr is initialized at session\ncreation time.\n\n\nCurrent illixr integration for monado is a temporary solution and has some downsides because of the\nprogress from both monado and illixr.\n\n\n\n\n\n\nIt does not use the pose that user application declares to use at rendering (OpenXR\n   specification) because of monado internal interfaces. The pose difference used by timewarp comes\n   from the last pose query call.\n\n\n\n\n\n\nIt cannot submit frame with depth buffer.\n\n\n\n\n\n\nThe pose from illixr does not vary according to the OpenXR space. It is a raw pose data from slam\n   algorithms.\n\n\n\n\n\n\nNo controller action support at all.\n\n\n\n\n\n\nIt only supports gl user applications.\n\n\n\n\n\n\nUser application cannot acquire more than one swapchain image (for each eye) in one frame.\n\n\n\n\n\n\nIllixr is initialized during session creation time.",
            "title": "Monado integration dataflow"
        },
        {
            "location": "/monado_integration_dataflow/#monado-integration-dataflow",
            "text": "The integration for monado in terms of dataflow can be divided into two parts, getting pose from\nillixr, and sending user rendered frame to illixr.  In monado, illixr looks like an HMD for monado, while in illixr, monado looks like a user\napplication as  gldemo . After illixr is initialized from monado, and monado is registered as a\nplugin for illixr, most recent pose information is easy to get from switchboard.  The compositor side of monado integration with illixr is done in more subtle way. Original monado\ncompositor mostly does distortion correction and aberration correction in a vulkan back-end\ncompositor. It also has two client compositor, one for opengl app, the other for vulkan app, which\npass frame data to the back-end compositor. Illixr integration intercepts the frame at gl client\ncompositor and sends it to switchboard of illixr, which is then used by  timewarp_gl  component.  In order to get a opengl frame and use it without copying pixels, illixr needs to get the user\napplication gl context. It is done at OpenXR session creation time, where illixr is\ninitialized. Note that logically illixr is initialized during OpenXR instance creation, or running\nat the background all the time. But, since illixr only supports single session at this time, and\nrequires a user application gl context upon initialization, illixr is initialized at session\ncreation time.  Current illixr integration for monado is a temporary solution and has some downsides because of the\nprogress from both monado and illixr.    It does not use the pose that user application declares to use at rendering (OpenXR\n   specification) because of monado internal interfaces. The pose difference used by timewarp comes\n   from the last pose query call.    It cannot submit frame with depth buffer.    The pose from illixr does not vary according to the OpenXR space. It is a raw pose data from slam\n   algorithms.    No controller action support at all.    It only supports gl user applications.    User application cannot acquire more than one swapchain image (for each eye) in one frame.    Illixr is initialized during session creation time.",
            "title": "Monado Integration Dataflow"
        },
        {
            "location": "/visualizer_logger/",
            "text": "Visualizer & Logger\n\n\nThere is a utility header file \ncommon/logger.hpp\n, which is a logger for recording process starting\nand ending time, with respect to the component initialization time. Currently, only \naudio_pipeline\n\nand \nhologram\nuse this logger. Please create a \nlog\n directory in your running binary directory to\nlet those log files correctly appear.\n\n\nlog/visualizer.py\nis a script to create visual timeline according to the log files in the same\ndirectory. It is not convenient to use or precisely correct right now.",
            "title": "Visualizer logger"
        },
        {
            "location": "/visualizer_logger/#visualizer-logger",
            "text": "There is a utility header file  common/logger.hpp , which is a logger for recording process starting\nand ending time, with respect to the component initialization time. Currently, only  audio_pipeline \nand  hologram use this logger. Please create a  log  directory in your running binary directory to\nlet those log files correctly appear.  log/visualizer.py is a script to create visual timeline according to the log files in the same\ndirectory. It is not convenient to use or precisely correct right now.",
            "title": "Visualizer &amp; Logger"
        },
        {
            "location": "/writing_your_plugin/",
            "text": "Writing your plugin\n\n\nAdding a new plugin (common case)\n\n\nIn the common case, one need only define a \nMakefile\n with the line \ninclude common/common.mk\n and\nsymlink common (\nln -s ../common common\n). This provides the necessary targets and uses the compiler\n\n$(CXX)\n, which is defined in Make based on the OS and environment variables.\n\n\n\n\n\n\nIt compiles \nplugin.cpp\n and any other \n*.cpp\n files into the plugin.\n\n\n\n\n\n\nIt will invoke a recompile the target any time any \n*.hpp\n or \n*.cpp\n file changes.\n\n\n\n\n\n\nIt compiles with C++17. You can change this in your plugin by defining \nSTDCXX = ...\n before the\n  \ninclude\n. This change will not affect other plugins; just yours.\n\n\n\n\n\n\nLibraries can be added by appending to \nLDFLAGS\n and \nCFLAGS\n, for example\n\n\nLDFLAGS := $(LDFLAGS) $(shell pkg-config --ldflags eigen3)\nCFLAGS := $(CFLAGS) $(shell pkg-config --cflags eigen3)\n\n\n\n\n\n\n\nSee the source for the exact flags.\n\n\n\n\n\n\nInserted the path of your directory into the \nplugin\n-list in \nconfig.yaml\n.\n\n\n\n\n\n\nAdding a plugin (general case)\n\n\nEach plugin can have a completely independent build system, as long as:\n- It defines a \nMakefile\n with targets for \nplugin.dbg.so\n, \nplugin.opt.so\n, and \nclean\n. Inside\n  this \nMakefile\n, one can defer to another build system.\n\n\n\n\n\n\nIt's compiler maintains \nABI compatibility\n with the compilers used in every other plugin. Using\n  the same version of Clang or GCC on the same architecture is sufficient for this.\n\n\n\n\n\n\nIt's path is inserted in the root \nconfig.yaml\n, in the plugin list.\n\n\n\n\n\n\nTutorial\n\n\nWith this, you can extend ILLIXR for your own purposes. You can also replace any existing\nfunctionality this way.\n\n\n\n\n\n\nCreate a new directory anywhere for your new plugin and set it up for ILLIXR. We recommend you also push this plugin to a git repository on Github/Gitlab if you want it as a part of upstream ILLIXR in the future.\n\n\n\n\n\n\nCreate a \nMakefile\n with the following contents. See \nBuilding ILLIXR\n for more details and alternative setups.\n\n\ninclude common.mk\n\n\n\n\n\n\n\nYou must decide if your plugin should inherit the standardized \nthreadloop\n or\n    \nplugin\n.\n\n\n\n\n\n\nIf your plugin just needs to run one computation repeatedly, then your plugin class should\n    extend \nthreadloop\n.\n\n\n\n\n\n\nIf you need custom concurrency (more complicated than a loop), triggered concurrency (by\n    events fired in other plugins), or no concurrency then your plugin class should extend\n    \nplugin\n.\n\n\n\n\n\n\nWrite a file called \nplugin.cpp\n with this body, replacing every instance of \nplugin_name\n:\n\n\n#include \"common/phonebook.hpp\"\n#include \"common/plugin.hpp\"\n#include \"common/threadloop.hpp\"\n\nusing namespace ILLIXR;\n\n// Inherit from `plugin` if you don't need the threadloop\nclass plugin_name : public threadloop {\npublic:\n    plugin_name(std::string name_, phonebook* pb_)\n        : threadloop{name_, pb_}\n        { }\n    virtual void start() override { }\n    virtual ~plugin_name() override { }\n};\n\n// This line makes the plugin importable by Spindle\nPLUGIN_MAIN(plugin_name);\n\n\n\n\n\n\n\nAt this point, you should be able to build your plugin with ILLIXR. Move to the ILLIXR repo and update \nconfigs/native.yaml\n. If the new plugin is the same type as one of the other components you will need to remove that component from the config before running the new component. For example, if the new component is a SLAM then the old SLAM needs to be removed from the config. See \nBuilding ILLIXR\n for more details on the config file.\n\n\nplugin_groups:\n  - !include \"rt_slam_plugins.yaml\"\n  - !include \"core_plugins.yaml\"\n  - plugin_group:\n     - path: /PATH/TO/NEW/PLUGIN\n     - path: ground_truth_slam/\n     - path: gldemo/\n     - path: debugview/\n\ndata:\n  subpath: mav0\n  relative_to:\n  archive_path:\n  download_url: 'http://robotics.ethz.ch/~asl-datasets/ijrr_euroc_mav_dataset/vicon_room1/V1_02_medium/V1_02_medium.zip'\n  demo_data: demo_data/\n  loader:\n    name: native\n    # command: gdb -q --args %a\n    profile: opt\n\n\n\n\n\n\n\nFinally, run ILLIXR with your new plugin with the following command: \n./runner.sh configs/native.yaml\n\n\n\n\n\n\nThis is all that is required to be a plugin which can be loaded by Spindle in the ILLIXR\n   runtime. Reading and writing from Phonebook and Switchboard is optional, but nearly every plugin\n   does it. See \ndefault_plugins.md\n for more details.\n\n\n\n\n\n\nFirst, we can query the \nphonebook\n to get various services including \nswitchboard\n. Then we\n   query \nswitchboard\n for event-streams (topics). We will read \ntopic1\n, write to \ntopic2\n, and\n   schedule computation on \ntopic 3\n. See the API documentation for \nphonebook\n and \nswitchboard\n\n   for more details.\n\n\n    #include \"common/phonebook.hpp\"\n    #include \"common/plugin.hpp\"\n    #include \"common/threadloop.hpp\"\n\n    /* When datatypes have to be common across plugins\n      (e.g. a phonebook service or switchboard topic),\n       they are defined in this header,\n       which is accessible to all plugins. */\n    #include \"common/data_format.hpp\"\n\n    class plugin_name : public threadloop {\n    public:\n        /*\n            After the constructor, C++ permits a list of member-constructors.\n            We use uniform initialization (curly-braces) [1] instead of parens to avoid ambiguity [2].\n            We put the comma at the start of the line, so that lines can be copied around or deleted freely (except for the first).\n\n            [1]: https://en.wikipedia.org/wiki/C%2B%2B11#Uniform_initialization\n            [2]: https://en.wikipedia.org/wiki/Most_vexing_parse\n        */\n        plugin_name(std::string name_, phonebook* pb_)\n            : threadloop{name_, pb_}\n              // find the switchboard in phonebook\n            , sb{pb->lookup_impl<switchboard>()}\n              // create a handle to a topic in switchboard for subscribing\n            , topic1{sb->subscribe_latest<topic1_type>(\"topic1\")}\n              // create a handle to a topic in switchboard for publishing\n            , topic2{sb->publish<topic2_type>(\"topic2\")}\n        {\n            // Read topic 1\n            topic1_type* event1 = topic1.get_latest_ro();\n\n            // Write to topic 2\n            topic2_type* event2 = new topic2_type;\n            topic2.put(event2);\n\n            // Read topic 3 synchronously\n            sb->schedule<topic3_type>(get_name(), \"topic3\", [&](const topic3_type *event3) {\n                /*\n                This is a [lambda expression][1]\n                [1]: https://en.cppreference.com/w/cpp/language/lambda\n                */\n                std::cout << \"Got a new event on topic3: \" << event3 << std::endl;\n            });\n        }\n\n        virtual void _p_one_iteration override() {\n            std::cout << \"Running\" << std::endl;\n            auto target = std::chrono::high_resolution_clock::now() +  std::chrono::milliseconds{10};\n            reliable_sleep(target);\n        }\n\n    private:\n        const std::shared_ptr<switchboard> sb;\n        std::unique_ptr<reader_latest<topic1_type>> topic1;\n        std::unique_ptr<writer<topic2>> topic2;\n    };\n\n    // This line makes the plugin importable by Spindle\n    PLUGIN_MAIN(plugin_name);",
            "title": "Writing your plugin"
        },
        {
            "location": "/writing_your_plugin/#writing-your-plugin",
            "text": "",
            "title": "Writing your plugin"
        },
        {
            "location": "/writing_your_plugin/#adding-a-new-plugin-common-case",
            "text": "In the common case, one need only define a  Makefile  with the line  include common/common.mk  and\nsymlink common ( ln -s ../common common ). This provides the necessary targets and uses the compiler $(CXX) , which is defined in Make based on the OS and environment variables.    It compiles  plugin.cpp  and any other  *.cpp  files into the plugin.    It will invoke a recompile the target any time any  *.hpp  or  *.cpp  file changes.    It compiles with C++17. You can change this in your plugin by defining  STDCXX = ...  before the\n   include . This change will not affect other plugins; just yours.    Libraries can be added by appending to  LDFLAGS  and  CFLAGS , for example  LDFLAGS := $(LDFLAGS) $(shell pkg-config --ldflags eigen3)\nCFLAGS := $(CFLAGS) $(shell pkg-config --cflags eigen3)    See the source for the exact flags.    Inserted the path of your directory into the  plugin -list in  config.yaml .",
            "title": "Adding a new plugin (common case)"
        },
        {
            "location": "/writing_your_plugin/#adding-a-plugin-general-case",
            "text": "Each plugin can have a completely independent build system, as long as:\n- It defines a  Makefile  with targets for  plugin.dbg.so ,  plugin.opt.so , and  clean . Inside\n  this  Makefile , one can defer to another build system.    It's compiler maintains  ABI compatibility  with the compilers used in every other plugin. Using\n  the same version of Clang or GCC on the same architecture is sufficient for this.    It's path is inserted in the root  config.yaml , in the plugin list.",
            "title": "Adding a plugin (general case)"
        },
        {
            "location": "/writing_your_plugin/#tutorial",
            "text": "With this, you can extend ILLIXR for your own purposes. You can also replace any existing\nfunctionality this way.    Create a new directory anywhere for your new plugin and set it up for ILLIXR. We recommend you also push this plugin to a git repository on Github/Gitlab if you want it as a part of upstream ILLIXR in the future.    Create a  Makefile  with the following contents. See  Building ILLIXR  for more details and alternative setups.  include common.mk    You must decide if your plugin should inherit the standardized  threadloop  or\n     plugin .    If your plugin just needs to run one computation repeatedly, then your plugin class should\n    extend  threadloop .    If you need custom concurrency (more complicated than a loop), triggered concurrency (by\n    events fired in other plugins), or no concurrency then your plugin class should extend\n     plugin .    Write a file called  plugin.cpp  with this body, replacing every instance of  plugin_name :  #include \"common/phonebook.hpp\"\n#include \"common/plugin.hpp\"\n#include \"common/threadloop.hpp\"\n\nusing namespace ILLIXR;\n\n// Inherit from `plugin` if you don't need the threadloop\nclass plugin_name : public threadloop {\npublic:\n    plugin_name(std::string name_, phonebook* pb_)\n        : threadloop{name_, pb_}\n        { }\n    virtual void start() override { }\n    virtual ~plugin_name() override { }\n};\n\n// This line makes the plugin importable by Spindle\nPLUGIN_MAIN(plugin_name);    At this point, you should be able to build your plugin with ILLIXR. Move to the ILLIXR repo and update  configs/native.yaml . If the new plugin is the same type as one of the other components you will need to remove that component from the config before running the new component. For example, if the new component is a SLAM then the old SLAM needs to be removed from the config. See  Building ILLIXR  for more details on the config file.  plugin_groups:\n  - !include \"rt_slam_plugins.yaml\"\n  - !include \"core_plugins.yaml\"\n  - plugin_group:\n     - path: /PATH/TO/NEW/PLUGIN\n     - path: ground_truth_slam/\n     - path: gldemo/\n     - path: debugview/\n\ndata:\n  subpath: mav0\n  relative_to:\n  archive_path:\n  download_url: 'http://robotics.ethz.ch/~asl-datasets/ijrr_euroc_mav_dataset/vicon_room1/V1_02_medium/V1_02_medium.zip'\n  demo_data: demo_data/\n  loader:\n    name: native\n    # command: gdb -q --args %a\n    profile: opt    Finally, run ILLIXR with your new plugin with the following command:  ./runner.sh configs/native.yaml    This is all that is required to be a plugin which can be loaded by Spindle in the ILLIXR\n   runtime. Reading and writing from Phonebook and Switchboard is optional, but nearly every plugin\n   does it. See  default_plugins.md  for more details.    First, we can query the  phonebook  to get various services including  switchboard . Then we\n   query  switchboard  for event-streams (topics). We will read  topic1 , write to  topic2 , and\n   schedule computation on  topic 3 . See the API documentation for  phonebook  and  switchboard \n   for more details.      #include \"common/phonebook.hpp\"\n    #include \"common/plugin.hpp\"\n    #include \"common/threadloop.hpp\"\n\n    /* When datatypes have to be common across plugins\n      (e.g. a phonebook service or switchboard topic),\n       they are defined in this header,\n       which is accessible to all plugins. */\n    #include \"common/data_format.hpp\"\n\n    class plugin_name : public threadloop {\n    public:\n        /*\n            After the constructor, C++ permits a list of member-constructors.\n            We use uniform initialization (curly-braces) [1] instead of parens to avoid ambiguity [2].\n            We put the comma at the start of the line, so that lines can be copied around or deleted freely (except for the first).\n\n            [1]: https://en.wikipedia.org/wiki/C%2B%2B11#Uniform_initialization\n            [2]: https://en.wikipedia.org/wiki/Most_vexing_parse\n        */\n        plugin_name(std::string name_, phonebook* pb_)\n            : threadloop{name_, pb_}\n              // find the switchboard in phonebook\n            , sb{pb->lookup_impl<switchboard>()}\n              // create a handle to a topic in switchboard for subscribing\n            , topic1{sb->subscribe_latest<topic1_type>(\"topic1\")}\n              // create a handle to a topic in switchboard for publishing\n            , topic2{sb->publish<topic2_type>(\"topic2\")}\n        {\n            // Read topic 1\n            topic1_type* event1 = topic1.get_latest_ro();\n\n            // Write to topic 2\n            topic2_type* event2 = new topic2_type;\n            topic2.put(event2);\n\n            // Read topic 3 synchronously\n            sb->schedule<topic3_type>(get_name(), \"topic3\", [&](const topic3_type *event3) {\n                /*\n                This is a [lambda expression][1]\n                [1]: https://en.cppreference.com/w/cpp/language/lambda\n                */\n                std::cout << \"Got a new event on topic3: \" << event3 << std::endl;\n            });\n        }\n\n        virtual void _p_one_iteration override() {\n            std::cout << \"Running\" << std::endl;\n            auto target = std::chrono::high_resolution_clock::now() +  std::chrono::milliseconds{10};\n            reliable_sleep(target);\n        }\n\n    private:\n        const std::shared_ptr<switchboard> sb;\n        std::unique_ptr<reader_latest<topic1_type>> topic1;\n        std::unique_ptr<writer<topic2>> topic2;\n    };\n\n    // This line makes the plugin importable by Spindle\n    PLUGIN_MAIN(plugin_name);",
            "title": "Tutorial"
        }
    ]
}