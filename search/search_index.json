{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ILLIXR Illinois Extended Reality testbed or ILLIXR (pronounced like elixir) is the first open-source full-system Extended Reality (XR) testbed. It contains standalone state-of-the-art components representative of a generic XR workflow, as well as a runtime framework that integrates these components into an XR system. ILLIXR's runtime integration framework is modular, extensible, and OpenXR -compatible. We use the term components and not kernels or computations because each component of ILLIXR is an entire application in itself, and consists of many kernels and computations. At the moment, ILLIXR contains the following state-of-the-art components, all of which can be found packaged together in the v1-latest release of ILLIXR. Simultaneous Localization and Mapping Scene reconstruction Eye tracking Ambisonic encoding Ambisonic manipulation and binauralization Lens distortion correction Chromatic aberration correction Time warp Computational holography for adaptive multi-focal displays We plan on adding more components (e.g., graphics and multiple versions for individual components) and extending the runtime in the future. Our goal is not to create a commercial quality XR product for current hardware. Instead, the goal for ILLIXR is to advance computer architecture, systems, and hardware-software co-design research for XR by making available a full system and key state-of-the-art components of both modern and future XR applications. Many of the current components of ILLIXR were developed by domain experts and obtained from publicly available repositories. They were modified for one or more of the following reasons: fixing compilation, adding features, or removing extraneous code or dependencies. Each component not developed by us is available as a forked github repository for proper attribution to its authors. Detailed descriptions of each component and our runtime, including performance and energy profiles, can be found in our paper . Publications We request that you cite our following paper (new version coming soon) when you use ILLIXR for a publication. We would also appreciate it if you send us a citation once your work has been published. @misc{HuzaifaDesai2020, title={Exploring Extended Reality with ILLIXR: A new Playground for Architecture Research}, author={Muhammad Huzaifa and Rishi Desai and Xutao Jiang and Joseph Ravichandran and Finn Sinclair and Sarita V. Adve}, year={2020}, eprint={2004.04643}, primaryClass={cs.DC} } Getting Started and Documentation For more information, see our getting started page . Acknowledgements Muhammad Huzaifa led the development of ILLIXR in Sarita Adve\u2019s research group at the University of Illinois at Urbana-Champaign. Other major contributors include Rishi Desai, Samuel Grayson, Xutao Jiang, Ying Jing, Jae Lee, Fang Lu, Joseph Ravichandran, Finn Sinclair, Henghzhi Yuan, Jeffrey Zhang. ILLIXR came together after many consultations with researchers and practitioners in many domains: audio, graphics, optics, robotics, signal processing, and extended reality systems. We are deeply grateful for all of these discussions and specifically to the following: Wei Cu, Aleksandra Faust, Liang Gao, Matt Horsnell, Amit Jindal, Steve LaValle, Steve Lovegrove, Andrew Maimone, Vegard \u00d8ye, Martin Persson, Archontis Politis, Eric Shaffer, Paris Smaragdis, Sachin Talathi, and Chris Widdowson. Our OpenXR implementation is derived from Monado . We are particularly thankful to Jakob Bornecrantz and Ryan Pavlik. The development of ILLIXR was supported by the Applications Driving Architectures (ADA) Research Center, a JUMP Center co-sponsored by SRC and DARPA, the Center for Future Architectures Research (C-FAR), one of the six centers of STARnet, a Semiconductor Research Corporation program sponsored by MARCO and DARPA, and by a Google Faculty Research Award. The development of ILLIXR was also aided by generous hardware and software donations from ARM and NVIDIA. Facebook Reality Labs provided the OpenEDS Semantic Segmentation Dataset . Wesley Darvin came up with the name for ILLIXR. Licensing Structure ILLIXR is available as open-source software under the University of Illinois/NCSA Open Source License . As mentioned above, ILLIXR largely consists of components developed by domain experts and modified for the purposes of inclusion in ILLIXR. However, ILLIXR does contain software developed solely by us. The NCSA license is limited to only this software . The external libraries and softwares included in ILLIXR each have their own licenses and must be used according to those licenses: Open-VINS - GNU General Public License v3.0 ElasticFusion - ElasticFusion license RITnet - MIT License libspatialaudio - GNU Lesser General Public License v2.1 HOTlab - GNU Lesser General Public License v3.0 Monado - Boost Software License 1.0 Get In Touch Whether you are a computer architect, a systems person, an XR application developer, or just anyone interested in XR, we would love to hear your feedback on ILLIXR! ILLIXR is a living testbed and we would like to both refine existing components and add new ones. We believe ILLIXR has the opportunity to drive future computer architecture and systems research for XR, and can benefit from contributions from other researchers and organizations. If you would like to be a part of this effort, please contact us at illixr at cs dot illinois dot edu or visit us on Gitter or just send us a pull request!","title":"ILLIXR"},{"location":"#illixr","text":"Illinois Extended Reality testbed or ILLIXR (pronounced like elixir) is the first open-source full-system Extended Reality (XR) testbed. It contains standalone state-of-the-art components representative of a generic XR workflow, as well as a runtime framework that integrates these components into an XR system. ILLIXR's runtime integration framework is modular, extensible, and OpenXR -compatible. We use the term components and not kernels or computations because each component of ILLIXR is an entire application in itself, and consists of many kernels and computations. At the moment, ILLIXR contains the following state-of-the-art components, all of which can be found packaged together in the v1-latest release of ILLIXR. Simultaneous Localization and Mapping Scene reconstruction Eye tracking Ambisonic encoding Ambisonic manipulation and binauralization Lens distortion correction Chromatic aberration correction Time warp Computational holography for adaptive multi-focal displays We plan on adding more components (e.g., graphics and multiple versions for individual components) and extending the runtime in the future. Our goal is not to create a commercial quality XR product for current hardware. Instead, the goal for ILLIXR is to advance computer architecture, systems, and hardware-software co-design research for XR by making available a full system and key state-of-the-art components of both modern and future XR applications. Many of the current components of ILLIXR were developed by domain experts and obtained from publicly available repositories. They were modified for one or more of the following reasons: fixing compilation, adding features, or removing extraneous code or dependencies. Each component not developed by us is available as a forked github repository for proper attribution to its authors. Detailed descriptions of each component and our runtime, including performance and energy profiles, can be found in our paper .","title":"ILLIXR"},{"location":"#publications","text":"We request that you cite our following paper (new version coming soon) when you use ILLIXR for a publication. We would also appreciate it if you send us a citation once your work has been published. @misc{HuzaifaDesai2020, title={Exploring Extended Reality with ILLIXR: A new Playground for Architecture Research}, author={Muhammad Huzaifa and Rishi Desai and Xutao Jiang and Joseph Ravichandran and Finn Sinclair and Sarita V. Adve}, year={2020}, eprint={2004.04643}, primaryClass={cs.DC} }","title":"Publications"},{"location":"#getting-started-and-documentation","text":"For more information, see our getting started page .","title":"Getting Started and Documentation"},{"location":"#acknowledgements","text":"Muhammad Huzaifa led the development of ILLIXR in Sarita Adve\u2019s research group at the University of Illinois at Urbana-Champaign. Other major contributors include Rishi Desai, Samuel Grayson, Xutao Jiang, Ying Jing, Jae Lee, Fang Lu, Joseph Ravichandran, Finn Sinclair, Henghzhi Yuan, Jeffrey Zhang. ILLIXR came together after many consultations with researchers and practitioners in many domains: audio, graphics, optics, robotics, signal processing, and extended reality systems. We are deeply grateful for all of these discussions and specifically to the following: Wei Cu, Aleksandra Faust, Liang Gao, Matt Horsnell, Amit Jindal, Steve LaValle, Steve Lovegrove, Andrew Maimone, Vegard \u00d8ye, Martin Persson, Archontis Politis, Eric Shaffer, Paris Smaragdis, Sachin Talathi, and Chris Widdowson. Our OpenXR implementation is derived from Monado . We are particularly thankful to Jakob Bornecrantz and Ryan Pavlik. The development of ILLIXR was supported by the Applications Driving Architectures (ADA) Research Center, a JUMP Center co-sponsored by SRC and DARPA, the Center for Future Architectures Research (C-FAR), one of the six centers of STARnet, a Semiconductor Research Corporation program sponsored by MARCO and DARPA, and by a Google Faculty Research Award. The development of ILLIXR was also aided by generous hardware and software donations from ARM and NVIDIA. Facebook Reality Labs provided the OpenEDS Semantic Segmentation Dataset . Wesley Darvin came up with the name for ILLIXR.","title":"Acknowledgements"},{"location":"#licensing-structure","text":"ILLIXR is available as open-source software under the University of Illinois/NCSA Open Source License . As mentioned above, ILLIXR largely consists of components developed by domain experts and modified for the purposes of inclusion in ILLIXR. However, ILLIXR does contain software developed solely by us. The NCSA license is limited to only this software . The external libraries and softwares included in ILLIXR each have their own licenses and must be used according to those licenses: Open-VINS - GNU General Public License v3.0 ElasticFusion - ElasticFusion license RITnet - MIT License libspatialaudio - GNU Lesser General Public License v2.1 HOTlab - GNU Lesser General Public License v3.0 Monado - Boost Software License 1.0","title":"Licensing Structure"},{"location":"#get-in-touch","text":"Whether you are a computer architect, a systems person, an XR application developer, or just anyone interested in XR, we would love to hear your feedback on ILLIXR! ILLIXR is a living testbed and we would like to both refine existing components and add new ones. We believe ILLIXR has the opportunity to drive future computer architecture and systems research for XR, and can benefit from contributions from other researchers and organizations. If you would like to be a part of this effort, please contact us at illixr at cs dot illinois dot edu or visit us on Gitter or just send us a pull request!","title":"Get In Touch"},{"location":"building_illixr/","text":"Building ILLIXR Basic usage We have a tool called runner.sh that downloads, compiles, and runs ILLIXR. This is necessary, since ILLIXR has plugins and data are in many different places. The tool consumes a config YAML file which specifies those places. To run ILLIXR natively, use ./runner.sh configs/native.yaml To drop into gdb , add command: gdb -q --args %a in the loader block of configs/native.yaml , and use the same command. To run ILLIXR with Monado, ./runner.sh configs/monado.yaml The OpenXR application to run is defined in loader.openxr_app . Config file See config/{native,ci,native-ground-truth,monado}.yaml . The first block in the config file contains a list of plugin_groups , where each plugin_group is a list of plugins. plugin_groups: - plugin_group: - path: plugin1/ - path: plugin2/ - path: plugin3/ - path: plugin4/ This defines a list of plugins by their location, path . Allowed paths will be described below. The plugin_groups get flattened and those plugins are initialized in order at runtime. Several of the default plugins are order-sensitive. The next block in the config defines the offline IMU data, camera data, and ground-truth data. data: subpath: mav0 relative_to: archive_path: download_url: 'http://robotics.ethz.ch/~asl-datasets/ijrr_euroc_mav_dataset/vicon_room1/V1_02_medium/V1_02_medium.zip' Next, we define the location of OBJ files for gldemo . demo_data: demo_data/ Currently we support the following loaders: native (which runs ILLIXR in standalone mode), tests (which runs integreation tests headlessly for CI/CD purposes), and monado (which runs an OpenXR application in Monado using ILLIXR as a backend). loader: name: native command: gdb -q --args %a The native loader supports an optional command argument. In that argument %a is replaced with the separated command-line arguments to run ILLIR, while %b is replaced with the stringified command-line arguments. Finally, we support two profiles: opt , which compiles with -O3 and disables debug prints, and dbg , which compiles with debug flags and enables debug prints. profile: opt You can !include other YAML files ( documentation ). Consider separating the site-specific configuration options into its own file. Specifying Paths A path refers to a location of a resource. There are 5 ways of specifying a path: Simple path : either absolute or relative path in the native filesystem. Git repo : A git repository. - git_repo: https://github.com/user/repo.git version: master # branch name, SHA-256, or tag Download URL : A resource downloaded from the internet. - download_url: https://example.com/file.txt Zip archive : A path that points within the contents of a zip archive. Note that archive_path is itself a path (recursive). - archive_path: path/to/archive.zip - archive_path: download_url: https://example.com/file.zip Complex path : A hard-coded path relative to another path (recursive). This is useful to specify a subdirectory of a git repository or zip archive. - subpath: path/within/git_repo relative_to: git_repo: ... version: ... Rationale Previously, we would have to specify which plugins to build and which to run separately, violating DRY principle . Previously, configuration had to be hard-coded into the component source code, or passed as parsed/unparsed as strings in env-vars on a per-component basis. This gives us a consistent way to deal with all configurations. Currently, plugins are specificed by a path to the directory containing their source code and build system. Philosophy Each plugin should not have to know or care how the others are compiled. In the future, they may even be distributed separately, just as SOs. Therefore, each plugin needs its own build system. Despite this per-plugin flexibility, building the 'default' set of ILLIXR plugins should be extremely easy. It should be easy to build in parallel. Always rebuild every time, so the binary is always \"fresh\". This is a great convenience when experimenting. However, this implies that rebuilding must be fast when not much has changed. Make is the de facto standard for building C/C++ programs. GNU Make, and the makefile language begets no shortage of problems [ 1 , 2 , 3 , 4 , 5 ], but we choose Make for its tradeoff of between simplicity and functionality. What it lacks in functionality (compared to CMake, Ninja, scons, Bazel, Meson) it makes up for in simplicity. It's still the build system in which it is the easiest to invoke arbitrary commands in shell and the easiest to have a common.mk included in each plugin. This decision to use Make should be revisited, when this project outgrows its ability, but for now, Make remains, in our judgement, the best tool for the job .","title":"Building ILLIXR"},{"location":"building_illixr/#building-illixr","text":"","title":"Building ILLIXR"},{"location":"building_illixr/#basic-usage","text":"We have a tool called runner.sh that downloads, compiles, and runs ILLIXR. This is necessary, since ILLIXR has plugins and data are in many different places. The tool consumes a config YAML file which specifies those places. To run ILLIXR natively, use ./runner.sh configs/native.yaml To drop into gdb , add command: gdb -q --args %a in the loader block of configs/native.yaml , and use the same command. To run ILLIXR with Monado, ./runner.sh configs/monado.yaml The OpenXR application to run is defined in loader.openxr_app .","title":"Basic usage"},{"location":"building_illixr/#config-file","text":"See config/{native,ci,native-ground-truth,monado}.yaml . The first block in the config file contains a list of plugin_groups , where each plugin_group is a list of plugins. plugin_groups: - plugin_group: - path: plugin1/ - path: plugin2/ - path: plugin3/ - path: plugin4/ This defines a list of plugins by their location, path . Allowed paths will be described below. The plugin_groups get flattened and those plugins are initialized in order at runtime. Several of the default plugins are order-sensitive. The next block in the config defines the offline IMU data, camera data, and ground-truth data. data: subpath: mav0 relative_to: archive_path: download_url: 'http://robotics.ethz.ch/~asl-datasets/ijrr_euroc_mav_dataset/vicon_room1/V1_02_medium/V1_02_medium.zip' Next, we define the location of OBJ files for gldemo . demo_data: demo_data/ Currently we support the following loaders: native (which runs ILLIXR in standalone mode), tests (which runs integreation tests headlessly for CI/CD purposes), and monado (which runs an OpenXR application in Monado using ILLIXR as a backend). loader: name: native command: gdb -q --args %a The native loader supports an optional command argument. In that argument %a is replaced with the separated command-line arguments to run ILLIR, while %b is replaced with the stringified command-line arguments. Finally, we support two profiles: opt , which compiles with -O3 and disables debug prints, and dbg , which compiles with debug flags and enables debug prints. profile: opt You can !include other YAML files ( documentation ). Consider separating the site-specific configuration options into its own file.","title":"Config file"},{"location":"building_illixr/#specifying-paths","text":"A path refers to a location of a resource. There are 5 ways of specifying a path: Simple path : either absolute or relative path in the native filesystem. Git repo : A git repository. - git_repo: https://github.com/user/repo.git version: master # branch name, SHA-256, or tag Download URL : A resource downloaded from the internet. - download_url: https://example.com/file.txt Zip archive : A path that points within the contents of a zip archive. Note that archive_path is itself a path (recursive). - archive_path: path/to/archive.zip - archive_path: download_url: https://example.com/file.zip Complex path : A hard-coded path relative to another path (recursive). This is useful to specify a subdirectory of a git repository or zip archive. - subpath: path/within/git_repo relative_to: git_repo: ... version: ...","title":"Specifying Paths"},{"location":"building_illixr/#rationale","text":"Previously, we would have to specify which plugins to build and which to run separately, violating DRY principle . Previously, configuration had to be hard-coded into the component source code, or passed as parsed/unparsed as strings in env-vars on a per-component basis. This gives us a consistent way to deal with all configurations. Currently, plugins are specificed by a path to the directory containing their source code and build system.","title":"Rationale"},{"location":"building_illixr/#philosophy","text":"Each plugin should not have to know or care how the others are compiled. In the future, they may even be distributed separately, just as SOs. Therefore, each plugin needs its own build system. Despite this per-plugin flexibility, building the 'default' set of ILLIXR plugins should be extremely easy. It should be easy to build in parallel. Always rebuild every time, so the binary is always \"fresh\". This is a great convenience when experimenting. However, this implies that rebuilding must be fast when not much has changed. Make is the de facto standard for building C/C++ programs. GNU Make, and the makefile language begets no shortage of problems [ 1 , 2 , 3 , 4 , 5 ], but we choose Make for its tradeoff of between simplicity and functionality. What it lacks in functionality (compared to CMake, Ninja, scons, Bazel, Meson) it makes up for in simplicity. It's still the build system in which it is the easiest to invoke arbitrary commands in shell and the easiest to have a common.mk included in each plugin. This decision to use Make should be revisited, when this project outgrows its ability, but for now, Make remains, in our judgement, the best tool for the job .","title":"Philosophy"},{"location":"debugging_illixr/","text":"ILLIXR Debugging Tips Debugging Locally The config described in Building ILLIXR supports running the runtime with arbitrary commands like gdb . When debugging locally we recommend using either gdb or valgrind in this way. Debugging PRs Running the CI/CD Docker Container Locally Follow these steps when a CI/CD build fails on a PR: - Click details on the failing build - In the build view go to the Push Docker Image tab and copy the docker push ghcr.io/illixr/illixr-tests:<branch-name> command - Then in your terminal run docker pull ghcr.io/illixr/illixr-tests:<branch-name> - Finally run docker run -it --entrypoint /bin/bash ghcr.io/illixr/illixr-tests:<branch-name> This now gives you a bash shell in a docker container with all of the code that ran on CI/CD.","title":"ILLIXR Debugging Tips"},{"location":"debugging_illixr/#illixr-debugging-tips","text":"","title":"ILLIXR Debugging Tips"},{"location":"debugging_illixr/#debugging-locally","text":"The config described in Building ILLIXR supports running the runtime with arbitrary commands like gdb . When debugging locally we recommend using either gdb or valgrind in this way.","title":"Debugging Locally"},{"location":"debugging_illixr/#debugging-prs","text":"","title":"Debugging PRs"},{"location":"debugging_illixr/#running-the-cicd-docker-container-locally","text":"Follow these steps when a CI/CD build fails on a PR: - Click details on the failing build - In the build view go to the Push Docker Image tab and copy the docker push ghcr.io/illixr/illixr-tests:<branch-name> command - Then in your terminal run docker pull ghcr.io/illixr/illixr-tests:<branch-name> - Finally run docker run -it --entrypoint /bin/bash ghcr.io/illixr/illixr-tests:<branch-name> This now gives you a bash shell in a docker container with all of the code that ran on CI/CD.","title":"Running the CI/CD Docker Container Locally"},{"location":"default_plugins/","text":"Default Plugins offline_imu_cam : Reads IMU data and images from files on disk, emulating a real sensor on the headset (feeds input measurements with timing similar to an actual IMU). ground_truth_slam : Reads the ground-truth from the same dataset to compare our output against (uses timing from offline_imu_cam ). open_vins : Runs OpenVINS ( upstream ) on the input, and outputs a the headset's pose. In practice, this publishes a fairly slow pose, so pose prediction is required to infer a fast pose. We do not yet have pose prediction, so we say open_vins also publishes a fast pose. gldemo : Renders a static scene (into left and right eyebuffers) given the pose from open_vins . timewarp_gl : Asynchronous reprojection of the eyebuffers. debugview : Renders a frame for debug information. audio : TODO: this. By default this is disabled, since it requires an NVIDIA GPU. hologram : TODO: this. By default this is disabled, since it requires an NVIDIA GPU. Below this point, we will use Switchboard terminology. Read the API documentation on switchboard for definitions. In the above figure, rectangles are plugins, cylinders are topics (the graph is bipartitioned between these two gorups). Solid arrows from plugins to topics represent publishing. Solid arrows from topics to plugins represent synchronous reading. They take some action for every event which gets published on the topic. Solid arrows from topics to plugins represent asynchronous reading. They need to know just the latest event on their topic. Imagine the topic as a trough filing with events from its publisher, being drained by its synchronous readers (AKA subscribers), while asynchronous readres just skim from the top. See Writing Your Plugin to extend ILLIXR.","title":"Default Plugins"},{"location":"default_plugins/#default-plugins","text":"offline_imu_cam : Reads IMU data and images from files on disk, emulating a real sensor on the headset (feeds input measurements with timing similar to an actual IMU). ground_truth_slam : Reads the ground-truth from the same dataset to compare our output against (uses timing from offline_imu_cam ). open_vins : Runs OpenVINS ( upstream ) on the input, and outputs a the headset's pose. In practice, this publishes a fairly slow pose, so pose prediction is required to infer a fast pose. We do not yet have pose prediction, so we say open_vins also publishes a fast pose. gldemo : Renders a static scene (into left and right eyebuffers) given the pose from open_vins . timewarp_gl : Asynchronous reprojection of the eyebuffers. debugview : Renders a frame for debug information. audio : TODO: this. By default this is disabled, since it requires an NVIDIA GPU. hologram : TODO: this. By default this is disabled, since it requires an NVIDIA GPU. Below this point, we will use Switchboard terminology. Read the API documentation on switchboard for definitions. In the above figure, rectangles are plugins, cylinders are topics (the graph is bipartitioned between these two gorups). Solid arrows from plugins to topics represent publishing. Solid arrows from topics to plugins represent synchronous reading. They take some action for every event which gets published on the topic. Solid arrows from topics to plugins represent asynchronous reading. They need to know just the latest event on their topic. Imagine the topic as a trough filing with events from its publisher, being drained by its synchronous readers (AKA subscribers), while asynchronous readres just skim from the top. See Writing Your Plugin to extend ILLIXR.","title":"Default Plugins"},{"location":"getting_started/","text":"Getting Started ILLIXR Runtime These instructions have been tested with Ubuntu 18.04 and 20.04. Clone the repository: git clone --recursive --branch v2-latest https://github.com/ILLIXR/ILLIXR Update the submodules. Submodules are git repositories inside a git repository that need to be pulled down separately: git submodule update --init --recursive Install dependencies. This script installs some Ubuntu/Debian packages and builds several dependencies from source: ./install_deps.sh Inspect configs/native.yaml . The schema definition is in runner/config_schema.yaml . For more details on the runner and the config files, see Building ILLIXR . Build and run ILLIXR standalone: ./runner.sh configs/native.yaml If so desired, you can run ILLIXR headlessly using xvfb : ./runner.sh configs/headless.yaml ILLIXR Runtime with Monado (supports OpenXR) ILLIXR leverages Monado , an open-source implementation of OpenXR , to support a wide range of applications. Because of a low-level driver issue, Monado only supports Ubuntu 18.04+. Compile and run: ./runner.sh configs/monado.yaml ILLIXR Standalone ILLIXR can also benchmark each component in isolation. Clone the repository. git clone --recursive --branch v1-latest https://github.com/ILLIXR/ILLIXR Update the submodules. Submodules are git repositories inside a git repository that need to be pulled down separately. git submodule update --init --recursive Each component is a directory in benchmark . See those components for their documentation. Virtual Machine ILLIXR can be run inside a Qemu-KVM image. Check out the instructions here . Next steps The source code is divided into the following directories: - runtime : create a runnable binary that loads every plugin. * This contains Spindle, which is responsible for loading plugins. common : resources one might use in each plugin. Most plugins symlink this directory into theirs. Contains the interface for Switchboard, which maintains event-streams (implementation is in runtime ). Contains the interface for Phonebook, which is a service-directory (implementation is in runtime ). a directory for each plugin. Almost all of the XR functionality is implemented in plugins. See Default Components for more details. Try browsing the source of plugins. If you edit any of the source files, the runner will detect and rebuild the respective binary. If you want to add your own, see Writing Your Plugin .","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"","title":"Getting Started"},{"location":"getting_started/#illixr-runtime","text":"These instructions have been tested with Ubuntu 18.04 and 20.04. Clone the repository: git clone --recursive --branch v2-latest https://github.com/ILLIXR/ILLIXR Update the submodules. Submodules are git repositories inside a git repository that need to be pulled down separately: git submodule update --init --recursive Install dependencies. This script installs some Ubuntu/Debian packages and builds several dependencies from source: ./install_deps.sh Inspect configs/native.yaml . The schema definition is in runner/config_schema.yaml . For more details on the runner and the config files, see Building ILLIXR . Build and run ILLIXR standalone: ./runner.sh configs/native.yaml If so desired, you can run ILLIXR headlessly using xvfb : ./runner.sh configs/headless.yaml","title":"ILLIXR Runtime"},{"location":"getting_started/#illixr-runtime-with-monado-supports-openxr","text":"ILLIXR leverages Monado , an open-source implementation of OpenXR , to support a wide range of applications. Because of a low-level driver issue, Monado only supports Ubuntu 18.04+. Compile and run: ./runner.sh configs/monado.yaml","title":"ILLIXR Runtime with Monado (supports OpenXR)"},{"location":"getting_started/#illixr-standalone","text":"ILLIXR can also benchmark each component in isolation. Clone the repository. git clone --recursive --branch v1-latest https://github.com/ILLIXR/ILLIXR Update the submodules. Submodules are git repositories inside a git repository that need to be pulled down separately. git submodule update --init --recursive Each component is a directory in benchmark . See those components for their documentation.","title":"ILLIXR Standalone"},{"location":"getting_started/#virtual-machine","text":"ILLIXR can be run inside a Qemu-KVM image. Check out the instructions here .","title":"Virtual Machine"},{"location":"getting_started/#next-steps","text":"The source code is divided into the following directories: - runtime : create a runnable binary that loads every plugin. * This contains Spindle, which is responsible for loading plugins. common : resources one might use in each plugin. Most plugins symlink this directory into theirs. Contains the interface for Switchboard, which maintains event-streams (implementation is in runtime ). Contains the interface for Phonebook, which is a service-directory (implementation is in runtime ). a directory for each plugin. Almost all of the XR functionality is implemented in plugins. See Default Components for more details. Try browsing the source of plugins. If you edit any of the source files, the runner will detect and rebuild the respective binary. If you want to add your own, see Writing Your Plugin .","title":"Next steps"},{"location":"modifying_a_plugin/","text":"Modifying a plugin Tutorial This is how you can modify an existing ILLIXR plugin Clone the repository for the component you want to modify. e.g: git clone https://github.com/ILLIXR/audio_pipeline.git Modify the config file like this: Original Config plugin_group: - path: timewarp_gl/ - name: audio path: git_repo: https://github.com/ILLIXR/audio_pipeline.git version: 3433bb452b2ec661c9d3ef65d9cf3a2805e94cdc New Config plugin_group: - path: timewarp_gl/ - name: /PATH/TO/LOCAL/AUDIO-PLUGIN See the instructions on Building ILLIXR to learn how to run ILLIXR. To push the modification to upstream ILLIXR, push up the changes to the plugin's repository and modify the original config with the commit version updated. Then create a PR on the main ILLIXR repository.","title":"Modifying A Plugin"},{"location":"modifying_a_plugin/#modifying-a-plugin","text":"","title":"Modifying a plugin"},{"location":"modifying_a_plugin/#tutorial","text":"This is how you can modify an existing ILLIXR plugin Clone the repository for the component you want to modify. e.g: git clone https://github.com/ILLIXR/audio_pipeline.git Modify the config file like this: Original Config plugin_group: - path: timewarp_gl/ - name: audio path: git_repo: https://github.com/ILLIXR/audio_pipeline.git version: 3433bb452b2ec661c9d3ef65d9cf3a2805e94cdc New Config plugin_group: - path: timewarp_gl/ - name: /PATH/TO/LOCAL/AUDIO-PLUGIN See the instructions on Building ILLIXR to learn how to run ILLIXR. To push the modification to upstream ILLIXR, push up the changes to the plugin's repository and modify the original config with the commit version updated. Then create a PR on the main ILLIXR repository.","title":"Tutorial"},{"location":"monado_illixr_runtime_overview/","text":"Monado Integration Overview ILLIXR's plugins provide XR services, and the runtime ties them together. However, we don't want to force developers to write their wohle application specifically for ILLIXR. As such, we want to implement a common interface XR runtimes, such as OpenXR , so one application can work on several runtimes (including ours). In order to support OpenXR, we modified Monado , an existing, open-source implementation. When running ILLIXR without Monado, the Illixr runtime is the entry-point. Phonebook and switchboard are initialized and plugins are loaded, among which is the gldemo app. When running from Monado, however, as mandated by OpenXR specifications, the application is the entry point. As a result, the Illixr runtime system is loaded at a later point as a shared library. This article documents the changes to the Illixr runtime when an OpenXR application is used. 1. App launches and brings up Monado As specified by OpenXR, the OpenXR application initializes the OpenXR runtime by reading a configuration JSON file pointed to by an environment variable and loads the OpenXR runtime, which is Monado in this case, as a shared library into its address space. Consult the OpenXR specifications and the OpenXR-SDK from Khronous Group for more details. 2. Monado probes HMD devices and Illixr Initializes During initialization, Monado asks all drivers to probe for and initialize HMDs and controllers, internally known as xdev s. We have an Illixr driver, which will always respond to Monado with one discovered HMD that will be used to capture OpenXR queries and events from Monado's state tracker. The Illixr driver obtains the path to the Illixr runtime so file and a list of plugins from environment variables. After probing is finished, the application will start to create an OpenXR session. At some point in this process, the application will send its rendering context to the runtime, which we capture and send to the Illixr driver. At this moment, all necessary data is ready and Illixr will be launched. 3. Illixr Runtime Launch When used with Monado, the Illixr runtime is compiled into a shared library instead of an executable. The library exports its two major functionalities: initializing switchboard and phonebook, and load plugins. The drivers starts to load the runtime by loading the shared library into the current (the app's) address space and calls the switchboard and phonebook initialization. Then, it calls the plugin loading for each Illixr plugin (except gldemo, which is replaced by the OpenXR app). Finally, it calls a special plugin loading which takes a function address instead of a file path to load a translation plugin into Illixr as the application. The translation plugin will be in the next section. Each plugin should either not block or start its own thread, so the driver will be able to reacquire control and return to Monado and the app shortly. 4. The translation plugin When the app and all Illixr plugins are up and running, the translation plugin handles the connection between Monado and Illixr. It might be confusing to see that this plugin is part of the Illixr driver which is part of Monado while at the same time also part of Illixr as a plugin. But Monado and Illixr are running in different threads in the same address space. The translation plugin is the intersection of these two parallel systems serving as a bridge between the two. The translation plugin handles two types of events at the moment: pose requests and frame submissions. From the view of Monado, it is the destination of all requests: from the application, to Monado's state trackers, to the xdev interface who is responsible for servicing the request. From the view of Illixr, it behaves the same as the gldemo app: reading pose and submitting frames. For implementation details regarding the representation of poses and frames in Monado and in Illixr, please see Monado Integration Dataflow.","title":"Monado Integration Overview"},{"location":"monado_illixr_runtime_overview/#monado-integration-overview","text":"ILLIXR's plugins provide XR services, and the runtime ties them together. However, we don't want to force developers to write their wohle application specifically for ILLIXR. As such, we want to implement a common interface XR runtimes, such as OpenXR , so one application can work on several runtimes (including ours). In order to support OpenXR, we modified Monado , an existing, open-source implementation. When running ILLIXR without Monado, the Illixr runtime is the entry-point. Phonebook and switchboard are initialized and plugins are loaded, among which is the gldemo app. When running from Monado, however, as mandated by OpenXR specifications, the application is the entry point. As a result, the Illixr runtime system is loaded at a later point as a shared library. This article documents the changes to the Illixr runtime when an OpenXR application is used.","title":"Monado Integration Overview"},{"location":"monado_illixr_runtime_overview/#1-app-launches-and-brings-up-monado","text":"As specified by OpenXR, the OpenXR application initializes the OpenXR runtime by reading a configuration JSON file pointed to by an environment variable and loads the OpenXR runtime, which is Monado in this case, as a shared library into its address space. Consult the OpenXR specifications and the OpenXR-SDK from Khronous Group for more details.","title":"1. App launches and brings up Monado"},{"location":"monado_illixr_runtime_overview/#2-monado-probes-hmd-devices-and-illixr-initializes","text":"During initialization, Monado asks all drivers to probe for and initialize HMDs and controllers, internally known as xdev s. We have an Illixr driver, which will always respond to Monado with one discovered HMD that will be used to capture OpenXR queries and events from Monado's state tracker. The Illixr driver obtains the path to the Illixr runtime so file and a list of plugins from environment variables. After probing is finished, the application will start to create an OpenXR session. At some point in this process, the application will send its rendering context to the runtime, which we capture and send to the Illixr driver. At this moment, all necessary data is ready and Illixr will be launched.","title":"2.  Monado probes HMD devices and Illixr Initializes"},{"location":"monado_illixr_runtime_overview/#3-illixr-runtime-launch","text":"When used with Monado, the Illixr runtime is compiled into a shared library instead of an executable. The library exports its two major functionalities: initializing switchboard and phonebook, and load plugins. The drivers starts to load the runtime by loading the shared library into the current (the app's) address space and calls the switchboard and phonebook initialization. Then, it calls the plugin loading for each Illixr plugin (except gldemo, which is replaced by the OpenXR app). Finally, it calls a special plugin loading which takes a function address instead of a file path to load a translation plugin into Illixr as the application. The translation plugin will be in the next section. Each plugin should either not block or start its own thread, so the driver will be able to reacquire control and return to Monado and the app shortly.","title":"3. Illixr Runtime Launch"},{"location":"monado_illixr_runtime_overview/#4-the-translation-plugin","text":"When the app and all Illixr plugins are up and running, the translation plugin handles the connection between Monado and Illixr. It might be confusing to see that this plugin is part of the Illixr driver which is part of Monado while at the same time also part of Illixr as a plugin. But Monado and Illixr are running in different threads in the same address space. The translation plugin is the intersection of these two parallel systems serving as a bridge between the two. The translation plugin handles two types of events at the moment: pose requests and frame submissions. From the view of Monado, it is the destination of all requests: from the application, to Monado's state trackers, to the xdev interface who is responsible for servicing the request. From the view of Illixr, it behaves the same as the gldemo app: reading pose and submitting frames. For implementation details regarding the representation of poses and frames in Monado and in Illixr, please see Monado Integration Dataflow.","title":"4. The translation plugin"},{"location":"monado_integration_dataflow/","text":"Monado Integration Dataflow The integration for monado in terms of dataflow can be divided into two parts, getting pose from illixr, and sending user rendered frame to illixr. In monado, illixr looks like an HMD for monado, while in illixr, monado looks like a user application as gldemo . After illixr is initialized from monado, and monado is registered as a plugin for illixr, most recent pose information is easy to get from switchboard. The compositor side of monado integration with illixr is done in more subtle way. Original monado compositor mostly does distortion correction and aberration correction in a vulkan back-end compositor. It also has two client compositor, one for opengl app, the other for vulkan app, which pass frame data to the back-end compositor. Illixr integration intercepts the frame at gl client compositor and sends it to switchboard of illixr, which is then used by timewarp_gl component. In order to get a opengl frame and use it without copying pixels, illixr needs to get the user application gl context. It is done at OpenXR session creation time, where illixr is initialized. Note that logically illixr is initialized during OpenXR instance creation, or running at the background all the time. But, since illixr only supports single session at this time, and requires a user application gl context upon initialization, illixr is initialized at session creation time. Current illixr integration for monado is a temporary solution and has some downsides because of the progress from both monado and illixr. It does not use the pose that user application declares to use at rendering (OpenXR specification) because of monado internal interfaces. The pose difference used by timewarp comes from the last pose query call. It cannot submit frame with depth buffer. The pose from illixr does not vary according to the OpenXR space. It is a raw pose data from slam algorithms. No controller action support at all. It only supports gl user applications. User application cannot acquire more than one swapchain image (for each eye) in one frame. Illixr is initialized during session creation time.","title":"Monado Integration Dataflow"},{"location":"monado_integration_dataflow/#monado-integration-dataflow","text":"The integration for monado in terms of dataflow can be divided into two parts, getting pose from illixr, and sending user rendered frame to illixr. In monado, illixr looks like an HMD for monado, while in illixr, monado looks like a user application as gldemo . After illixr is initialized from monado, and monado is registered as a plugin for illixr, most recent pose information is easy to get from switchboard. The compositor side of monado integration with illixr is done in more subtle way. Original monado compositor mostly does distortion correction and aberration correction in a vulkan back-end compositor. It also has two client compositor, one for opengl app, the other for vulkan app, which pass frame data to the back-end compositor. Illixr integration intercepts the frame at gl client compositor and sends it to switchboard of illixr, which is then used by timewarp_gl component. In order to get a opengl frame and use it without copying pixels, illixr needs to get the user application gl context. It is done at OpenXR session creation time, where illixr is initialized. Note that logically illixr is initialized during OpenXR instance creation, or running at the background all the time. But, since illixr only supports single session at this time, and requires a user application gl context upon initialization, illixr is initialized at session creation time. Current illixr integration for monado is a temporary solution and has some downsides because of the progress from both monado and illixr. It does not use the pose that user application declares to use at rendering (OpenXR specification) because of monado internal interfaces. The pose difference used by timewarp comes from the last pose query call. It cannot submit frame with depth buffer. The pose from illixr does not vary according to the OpenXR space. It is a raw pose data from slam algorithms. No controller action support at all. It only supports gl user applications. User application cannot acquire more than one swapchain image (for each eye) in one frame. Illixr is initialized during session creation time.","title":"Monado Integration Dataflow"},{"location":"visualizer_logger/","text":"Visualizer & Logger There is a utility header file common/logger.hpp , which is a logger for recording process starting and ending time, with respect to the component initialization time. Currently, only audio_pipeline and hologram use this logger. Please create a log directory in your running binary directory to let those log files correctly appear. log/visualizer.py is a script to create visual timeline according to the log files in the same directory. It is not convenient to use or precisely correct right now.","title":"Visualizer & Logger"},{"location":"visualizer_logger/#visualizer-logger","text":"There is a utility header file common/logger.hpp , which is a logger for recording process starting and ending time, with respect to the component initialization time. Currently, only audio_pipeline and hologram use this logger. Please create a log directory in your running binary directory to let those log files correctly appear. log/visualizer.py is a script to create visual timeline according to the log files in the same directory. It is not convenient to use or precisely correct right now.","title":"Visualizer &amp; Logger"},{"location":"writing_your_plugin/","text":"Writing your plugin Adding a new plugin (common case) In the common case, one need only define a Makefile with the line include common/common.mk and symlink common ( ln -s ../common common ). This provides the necessary targets and uses the compiler $(CXX) , which is defined in Make based on the OS and environment variables. It compiles plugin.cpp and any other *.cpp files into the plugin. It will invoke a recompile the target any time any *.hpp or *.cpp file changes. It compiles with C++17. You can change this in your plugin by defining STDCXX = ... before the include . This change will not affect other plugins; just yours. Libraries can be added by appending to LDFLAGS and CFLAGS , for example LDFLAGS := $(LDFLAGS) $(shell pkg-config --ldflags eigen3) CFLAGS := $(CFLAGS) $(shell pkg-config --cflags eigen3) See the source for the exact flags. Inserted the path of your directory into the plugin -list in config.yaml . Adding a plugin (general case) Each plugin can have a completely independent build system, as long as: - It defines a Makefile with targets for plugin.dbg.so , plugin.opt.so , and clean . Inside this Makefile , one can defer to another build system. It's compiler maintains ABI compatibility with the compilers used in every other plugin. Using the same version of Clang or GCC on the same architecture is sufficient for this. It's path is inserted in the root config.yaml , in the plugin list. Tutorial With this, you can extend ILLIXR for your own purposes. You can also replace any existing functionality this way. Create a new directory anywhere for your new plugin and set it up for ILLIXR. We recommend you also push this plugin to a git repository on Github/Gitlab if you want it as a part of upstream ILLIXR in the future. Create a Makefile with the following contents. See Building ILLIXR for more details and alternative setups. include common.mk You must decide if your plugin should inherit the standardized threadloop or plugin . If your plugin just needs to run one computation repeatedly, then your plugin class should extend threadloop . If you need custom concurrency (more complicated than a loop), triggered concurrency (by events fired in other plugins), or no concurrency then your plugin class should extend plugin . Write a file called plugin.cpp with this body, replacing every instance of plugin_name : #include \"common/phonebook.hpp\" #include \"common/plugin.hpp\" #include \"common/threadloop.hpp\" using namespace ILLIXR; // Inherit from `plugin` if you don't need the threadloop class plugin_name : public threadloop { public: plugin_name(std::string name_, phonebook* pb_) : threadloop{name_, pb_} { } virtual void start() override { } virtual ~plugin_name() override { } }; // This line makes the plugin importable by Spindle PLUGIN_MAIN(plugin_name); At this point, you should be able to build your plugin with ILLIXR. Move to the ILLIXR repo and update configs/native.yaml . If the new plugin is the same type as one of the other components you will need to remove that component from the config before running the new component. For example, if the new component is a SLAM then the old SLAM needs to be removed from the config. See Building ILLIXR for more details on the config file. ``` plugin_groups: - !include \"rt_slam_plugins.yaml\" - !include \"core_plugins.yaml\" - plugin_group: - path: /PATH/TO/NEW/PLUGIN - path: ground_truth_slam/ - path: gldemo/ - path: debugview/ data: subpath: mav0 relative_to: archive_path: download_url: 'http://robotics.ethz.ch/~asl-datasets/ijrr_euroc_mav_dataset/vicon_room1/V1_02_medium/V1_02_medium.zip' demo_data: demo_data/ loader: name: native # command: gdb -q --args %a profile: opt ``` Finally, run ILLIXR with your new plugin with the following command: ./runner.sh configs/native.yaml This is all that is required to be a plugin which can be loaded by Spindle in the ILLIXR runtime. Reading and writing from Phonebook and Switchboard is optional, but nearly every plugin does it. See default_plugins.md for more details. First, we can query the phonebook to get various services including switchboard . Then we query switchboard for event-streams (topics). We will read topic1 , write to topic2 , and schedule computation on topic 3 . See the API documentation for phonebook and switchboard for more details. #include \"common/phonebook.hpp\" #include \"common/plugin.hpp\" #include \"common/threadloop.hpp\" /* When datatypes have to be common across plugins (e.g. a phonebook service or switchboard topic), they are defined in this header, which is accessible to all plugins. */ #include \"common/data_format.hpp\" class plugin_name : public threadloop { public: /* After the constructor, C++ permits a list of member-constructors. We use uniform initialization (curly-braces) [1] instead of parens to avoid ambiguity [2]. We put the comma at the start of the line, so that lines can be copied around or deleted freely (except for the first). [1]: https://en.wikipedia.org/wiki/C%2B%2B11#Uniform_initialization [2]: https://en.wikipedia.org/wiki/Most_vexing_parse */ plugin_name(std::string name_, phonebook* pb_) : threadloop{name_, pb_} // find the switchboard in phonebook , sb{pb->lookup_impl<switchboard>()} // create a handle to a topic in switchboard for subscribing , topic1{sb->subscribe_latest<topic1_type>(\"topic1\")} // create a handle to a topic in switchboard for publishing , topic2{sb->publish<topic2_type>(\"topic2\")} { // Read topic 1 topic1_type* event1 = topic1.get_latest_ro(); // Write to topic 2 topic2_type* event2 = new topic2_type; topic2.put(event2); // Read topic 3 synchronously sb->schedule<topic3_type>(get_name(), \"topic3\", [&](const topic3_type *event3) { /* This is a [lambda expression][1] [1]: https://en.cppreference.com/w/cpp/language/lambda */ std::cout << \"Got a new event on topic3: \" << event3 << std::endl; }); } virtual void _p_one_iteration override() { std::cout << \"Running\" << std::endl; auto target = std::chrono::high_resolution_clock::now() + std::chrono::milliseconds{10}; reliable_sleep(target); } private: const std::shared_ptr<switchboard> sb; std::unique_ptr<reader_latest<topic1_type>> topic1; std::unique_ptr<writer<topic2>> topic2; }; // This line makes the plugin importable by Spindle PLUGIN_MAIN(plugin_name);","title":"Writing Your Plugin"},{"location":"writing_your_plugin/#writing-your-plugin","text":"","title":"Writing your plugin"},{"location":"writing_your_plugin/#adding-a-new-plugin-common-case","text":"In the common case, one need only define a Makefile with the line include common/common.mk and symlink common ( ln -s ../common common ). This provides the necessary targets and uses the compiler $(CXX) , which is defined in Make based on the OS and environment variables. It compiles plugin.cpp and any other *.cpp files into the plugin. It will invoke a recompile the target any time any *.hpp or *.cpp file changes. It compiles with C++17. You can change this in your plugin by defining STDCXX = ... before the include . This change will not affect other plugins; just yours. Libraries can be added by appending to LDFLAGS and CFLAGS , for example LDFLAGS := $(LDFLAGS) $(shell pkg-config --ldflags eigen3) CFLAGS := $(CFLAGS) $(shell pkg-config --cflags eigen3) See the source for the exact flags. Inserted the path of your directory into the plugin -list in config.yaml .","title":"Adding a new plugin (common case)"},{"location":"writing_your_plugin/#adding-a-plugin-general-case","text":"Each plugin can have a completely independent build system, as long as: - It defines a Makefile with targets for plugin.dbg.so , plugin.opt.so , and clean . Inside this Makefile , one can defer to another build system. It's compiler maintains ABI compatibility with the compilers used in every other plugin. Using the same version of Clang or GCC on the same architecture is sufficient for this. It's path is inserted in the root config.yaml , in the plugin list.","title":"Adding a plugin (general case)"},{"location":"writing_your_plugin/#tutorial","text":"With this, you can extend ILLIXR for your own purposes. You can also replace any existing functionality this way. Create a new directory anywhere for your new plugin and set it up for ILLIXR. We recommend you also push this plugin to a git repository on Github/Gitlab if you want it as a part of upstream ILLIXR in the future. Create a Makefile with the following contents. See Building ILLIXR for more details and alternative setups. include common.mk You must decide if your plugin should inherit the standardized threadloop or plugin . If your plugin just needs to run one computation repeatedly, then your plugin class should extend threadloop . If you need custom concurrency (more complicated than a loop), triggered concurrency (by events fired in other plugins), or no concurrency then your plugin class should extend plugin . Write a file called plugin.cpp with this body, replacing every instance of plugin_name : #include \"common/phonebook.hpp\" #include \"common/plugin.hpp\" #include \"common/threadloop.hpp\" using namespace ILLIXR; // Inherit from `plugin` if you don't need the threadloop class plugin_name : public threadloop { public: plugin_name(std::string name_, phonebook* pb_) : threadloop{name_, pb_} { } virtual void start() override { } virtual ~plugin_name() override { } }; // This line makes the plugin importable by Spindle PLUGIN_MAIN(plugin_name); At this point, you should be able to build your plugin with ILLIXR. Move to the ILLIXR repo and update configs/native.yaml . If the new plugin is the same type as one of the other components you will need to remove that component from the config before running the new component. For example, if the new component is a SLAM then the old SLAM needs to be removed from the config. See Building ILLIXR for more details on the config file. ``` plugin_groups: - !include \"rt_slam_plugins.yaml\" - !include \"core_plugins.yaml\" - plugin_group: - path: /PATH/TO/NEW/PLUGIN - path: ground_truth_slam/ - path: gldemo/ - path: debugview/ data: subpath: mav0 relative_to: archive_path: download_url: 'http://robotics.ethz.ch/~asl-datasets/ijrr_euroc_mav_dataset/vicon_room1/V1_02_medium/V1_02_medium.zip' demo_data: demo_data/ loader: name: native # command: gdb -q --args %a profile: opt ``` Finally, run ILLIXR with your new plugin with the following command: ./runner.sh configs/native.yaml This is all that is required to be a plugin which can be loaded by Spindle in the ILLIXR runtime. Reading and writing from Phonebook and Switchboard is optional, but nearly every plugin does it. See default_plugins.md for more details. First, we can query the phonebook to get various services including switchboard . Then we query switchboard for event-streams (topics). We will read topic1 , write to topic2 , and schedule computation on topic 3 . See the API documentation for phonebook and switchboard for more details. #include \"common/phonebook.hpp\" #include \"common/plugin.hpp\" #include \"common/threadloop.hpp\" /* When datatypes have to be common across plugins (e.g. a phonebook service or switchboard topic), they are defined in this header, which is accessible to all plugins. */ #include \"common/data_format.hpp\" class plugin_name : public threadloop { public: /* After the constructor, C++ permits a list of member-constructors. We use uniform initialization (curly-braces) [1] instead of parens to avoid ambiguity [2]. We put the comma at the start of the line, so that lines can be copied around or deleted freely (except for the first). [1]: https://en.wikipedia.org/wiki/C%2B%2B11#Uniform_initialization [2]: https://en.wikipedia.org/wiki/Most_vexing_parse */ plugin_name(std::string name_, phonebook* pb_) : threadloop{name_, pb_} // find the switchboard in phonebook , sb{pb->lookup_impl<switchboard>()} // create a handle to a topic in switchboard for subscribing , topic1{sb->subscribe_latest<topic1_type>(\"topic1\")} // create a handle to a topic in switchboard for publishing , topic2{sb->publish<topic2_type>(\"topic2\")} { // Read topic 1 topic1_type* event1 = topic1.get_latest_ro(); // Write to topic 2 topic2_type* event2 = new topic2_type; topic2.put(event2); // Read topic 3 synchronously sb->schedule<topic3_type>(get_name(), \"topic3\", [&](const topic3_type *event3) { /* This is a [lambda expression][1] [1]: https://en.cppreference.com/w/cpp/language/lambda */ std::cout << \"Got a new event on topic3: \" << event3 << std::endl; }); } virtual void _p_one_iteration override() { std::cout << \"Running\" << std::endl; auto target = std::chrono::high_resolution_clock::now() + std::chrono::milliseconds{10}; reliable_sleep(target); } private: const std::shared_ptr<switchboard> sb; std::unique_ptr<reader_latest<topic1_type>> topic1; std::unique_ptr<writer<topic2>> topic2; }; // This line makes the plugin importable by Spindle PLUGIN_MAIN(plugin_name);","title":"Tutorial"}]}